<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有心有梦</title>
  
  <subtitle>YXYM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxym.run/"/>
  <updated>2020-03-07T06:48:31.981Z</updated>
  <id>http://yxym.run/</id>
  
  <author>
    <name>疯渔民</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Idea导入Java se程序无法正常run</title>
    <link href="http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:31.981Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。</p><p>程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。</p><a id="more"></a><ul><li>首先点击Idea左上角的“File”,然后找到“Project Structure ”配置选项</li><li>然后点击“Project setting”选项下的Project选项，设置JDK的版本，并且选择Project language level，因为我的Jdk版本是1.8，所以这里我选的是“Lambdas，type annotation etc”；然后在最下面设置项目的路径，即项目的完整工作空间路径。</li><li>点击“Modules”选项，选择右边方框里的蓝色“Sources”选项，将项目种的src文件设置为源代码文件夹，点击应用，最后点击ok即可运行。</li></ul><h3 id="关于Project-language-level"><a href="#关于Project-language-level" class="headerlink" title="关于Project language level"></a>关于Project language level</h3><p>我们应该知道 Java JDK 在每个新版本都会有其新特性，而新版本一般也会向下兼容旧版本的特性，在IntelliJ IDEA中 对这些 JDK 的新特性是这样介绍的：</p><ul><li>JDK 6 的新特性：@Override in interfaces</li><li>JDK 7 的新特性：Diamonds，ARM，multi-catch etc.</li><li>JDK 8 的新特性：Lambdas，type annotation etc.</li><li>JDK 9 的新特性：Jigsaw project etc.</li></ul><p>其中，当我们使用某一个版本的Jdk的时候，我们只能向下兼容，否则运行程序时是会运行不了的。比如我的Jdk的版本是1.8，那么我只能选择8及以下的language level。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。&lt;/p&gt;
&lt;p&gt;程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践问题总结" scheme="http://yxym.run/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Python的with关键字</title>
    <link href="http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:18.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、上下文管理器的概念"><a href="#1、上下文管理器的概念" class="headerlink" title="1、上下文管理器的概念"></a>1、上下文管理器的概念</h4><p><strong>上下文管理协议（Context Management Protocol）：</strong></p><pre><code>包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 </code></pre><p><strong>上下文管理器（Context Manager）</strong>：</p><pre><code>支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 </code></pre><a id="more"></a><p><strong>运行时上下文（runtime context）：</strong></p><pre><code>由上下文管理器创建，通过上下文管理器的 __enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。 </code></pre><p><strong>上下文表达式（Context Expression）</strong>：</p><pre><code>with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。 </code></pre><p><strong>语句体（with-body）</strong>：</p><pre><code>with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行__exit__() 方法。</code></pre><h4 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h4><p>with表达式其实是try-finally的简写形式。但是又不是全相同。</p><p><strong>格式</strong></p><pre><code>with context [as var]:    pass</code></pre><p>context 是一个表达式，返回的就是支持上下文管理协议的对象，var这个变量用来保存context表达式返回的对象，可以有单个或者多个返回值。</p><pre><code>with open(&apos;test1.txt&apos;) as f:        f.read()</code></pre><p> 表达式open(‘test1.txt’)返回的是一个    _io.TextIOWrapper 类型的对象变量，用f来保存，在with语句块中就可以使用这个变量操作文件。执行with这个结构之后。f会自动关闭，相当于自带了一个finally。</p><p> 注意：with本身并没有异常捕获的功能，但是如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p> 对于自定义的类想要正确使用with关键字，必须实现上述的几个方法才可以：</p><pre><code>class Sample:   def __enter__(self):           pass      def __exit__(self, type, value, trace):           pass</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、上下文管理器的概念&quot;&gt;&lt;a href=&quot;#1、上下文管理器的概念&quot; class=&quot;headerlink&quot; title=&quot;1、上下文管理器的概念&quot;&gt;&lt;/a&gt;1、上下文管理器的概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;上下文管理协议（Context Management Protocol）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;上下文管理器（Context Manager）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python基础知识笔记" scheme="http://yxym.run/categories/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第190题</title>
    <link href="http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:27:08.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</code></pre><a id="more"></a><p><strong>注意：</strong><br>我用的是Java语言，但是在Java语言中，没有无符号整型，在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响我们的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p><strong>解题思路：</strong></p><p>将一个32位的整数的二进制形式进行翻转，对于二进制形式的数，可以考虑采用位运算。并且需要注意的是有一点是对于任意的整数n，对它与1进行进行“与”运算，最终得到的结果都取决于该数字最后一位，如果是1，则说明n的二进制形式中，最后一位是1；如果是0，则说明n的二进制形式中，最后一位是0。通过这种方式，可以逐个的提取n的二进制位中的每一位数字。基于以上思路，有以下两种翻转方式：</p><ol><li>从左向右移位置，提取最后一位，从右向左移位，或运算</li></ol><p>取一个游标变量i，其取值从31到0，表示先提取n的二进制形式的最后一位，然后将倒数第二位右移到最后一位，提取；继续将倒数第三位右移到最后一位，，以此类推。代码如下：</p><pre><code>（n &gt;&gt; (31-i)）&amp; 1</code></pre><p>取完最后一位的值以后，将其进行左移，左移的位数整数前边右移时的游标变量i的值，根据对称的性质可知，翻转正是将第31位移到第0位，第30位移到第1位；代码如下：</p><pre><code>（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>再声明一个结果变量result，初始值为0，它将与每次左移后的结果进行“或”运算，经过31次或运算之后，它就是最终的翻转的结果值。</p><pre><code>result |（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>完整的代码实现如下：</p><pre><code>public int reverseBits(int n) {       int ret = 0;    for (int i =31;i&gt;=0;i--){       ret = ret | (((n&gt;&gt;(31-i))&amp;1) &lt;&lt; i);   }   return ret; }</code></pre><p>  ii. 第二种方式，是我在题解中看到的一个内存空间消耗较少的程序，因为上一个方法虽然运行时间特别快，超过了100%的人，但是内存消耗却只超过了5%的人的程序。在这个方式中，也是声明了一个结果变量ret，但是它并没有先右移，然后提取，再左移，最后或运算；而是也对res变量进行移位操作，即先将res左移，提取完原数的最后一位之后与res或运算，然后直接将就地对n右移，完整的代码如下：</p><pre><code>public int reverseBits2(int n){    int res = 0;    int count = 0;    while (count &lt; 32) {        res &lt;&lt;= 1;        res |= (n &amp; 1);        n &gt;&gt;= 1;        count ++;    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>GO语言学习之函数</title>
    <link href="http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/</id>
    <published>2020-02-26T14:41:00.000Z</published>
    <updated>2020-02-26T14:43:50.613Z</updated>
    
    <content type="html"><![CDATA[<p>在go语言中,函数存在以下几个与其他编程语言显著不同的地方:<br>1、函数可以有多个返回值<br>2、所有的参数传递都是值传递的方式<br>3、函数可以作为变量的值<br>4、函数可以作为参数和返回值</p><p>本文主要针对第四点来进行笔记记录</p><a id="more"></a><h3 id="函数可以作为参数和返回值"><a href="#函数可以作为参数和返回值" class="headerlink" title="函数可以作为参数和返回值"></a>函数可以作为参数和返回值</h3><p>首先定义一个函数timeSpent，它的作用类似于面向对象编程中的装饰者模式，对一个函数“装饰”上记录运行时间的功能，以此来衡量一个函数的运行时间，其中被衡量的函数是作为参数传入到timeSpent中去的，代码如下：</p><pre><code>func timeSpent(inner func(op int) int) func (opt int) int{return func(n int) int {    start := time.Now()    ret := inner(n)    fmt.Println(&quot;time spent&quot;,time.Since(start).Seconds())    return ret}}</code></pre><p>其中，传入的参数是一个函数类型，该参数函数的返回值是一个整型，timeSpent的返回值类型也为一个函数类型。</p><p>然后定义一个用来测试的函数：</p><pre><code>func slowFun(op int) int{    time.Sleep(time.Second*1)    return  op}</code></pre><p>该函数并没有多余的功能，只是将传入的参数再次原值返回，期间函数会休眠一段时间。</p><p>调用执行：</p><pre><code>func TestFn(t *testing.T)  {tsSF := timeSpent(slowFun)t.Log(tsSF(10))}</code></pre><p>程序的执行过程如下：<br>1、首先将slowFun函数作为参数传入到timeSpent中去，然后将其装饰为一个具有记录运行时间的函数后，返回一个被装饰的函数，return后方的函数内部逻辑并不执行，只是将原有的函数进行装饰；<br>2、tsSF被赋予一个函数，该函数的具体业务逻辑等同于timeSpent函数中return语句后方的函数；<br>3、调用执行tsSF，传入参数10，执行逻辑见timeSpent中return语句后方的部分，打印输出10。</p><p>以上就是go语言中函数作为参数和返回值的实例，此种编程模式也成为函数式编程，可以在《计算机程序的构造与解释》这本书中了解更多更深入的关于函数式编程的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在go语言中,函数存在以下几个与其他编程语言显著不同的地方:&lt;br&gt;1、函数可以有多个返回值&lt;br&gt;2、所有的参数传递都是值传递的方式&lt;br&gt;3、函数可以作为变量的值&lt;br&gt;4、函数可以作为参数和返回值&lt;/p&gt;
&lt;p&gt;本文主要针对第四点来进行笔记记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go语言学习笔记" scheme="http://yxym.run/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>大学回忆一</title>
    <link href="http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2020-02-26T15:18:24.181Z</updated>
    
    <content type="html"><![CDATA[<p>时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。<a id="more"></a>回望本科四年，心中却没有泛起丝毫波澜，或许是因为大学生活过的平凡无奇，或许是因为年过20早已没有了十几岁的热情与心气。</p><p>本科四年，是我特别想要证明自己的四年，或许是因为对高考结果的不满，或许是因为对自己的不甘心，总之在踏入校园的那一刻起，我发誓我一定要做一个追逐优秀的人，我没有对任何说，因为我也不认识任何人，哈哈哈。可就是这股力量一直在驱动着我前进，我努力地学习每一门课程，以使自己对所学的课程都能有一个深刻的认识与理解而不是简单地只为拿一个不错的期末分数，诚然，我这么学，每一门分数也都是很理想的，当然，英语除外，其实我当年英语也他挺好的，只是后来碰到了一位经常把我讲睡着的英语老师，然后就对英语彻底丧失了兴趣，以至于英语成绩一直不愠不火，哈哈哈。</p><p>我大学是软件工程，其实我在上大学之前对计算机的认识只有能打游戏和能做PPT这两种认识，更别说那些什么CPU、GPU、内存等什么专业术语，一开学的时候我挺自卑的，因为别人能一起侃侃而谈，我却对此一窍不通，这种感觉严重的刺痛了我，妈的，老子不能服输，因此我一边学习理论知识，一边了解计算机相关的知识，不管是硬件还是软件，只要是和Computer相关，我都会刻意去了解，慢慢滴也对这些知识熟悉了起来。另一个自卑的就是自己的编程能力了，有的同学大一的时候就能参加竞赛拿奖而我还只是一个臭弟弟，没办法，我这个人就是比较的自找没趣，喜欢和比我强的人比，也许是我争强好胜的原因，其实这一点挺不好的，因为容易把自己的心态搞砸了，心态一旦失衡，做什么事都容易翻车。扯远了，继续刚才的话题，为让自己也能编程能力有个大的提高，自己也在寒暑假学习编程语言，练习编程。虽然不能说自己能力提高了很多，但是起码上手的速度快了很多。现在回忆那些生活，突然有些小怀念了，哈哈哈，总之那段生活挺单调的，因为自己没交多少朋友，甚至能连学校有多少好吃的都不知道哈哈哈，因为每天标准的吃米饭套餐，哎，人生苦短，要及时行乐啊，不能苦了自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。
    
    </summary>
    
    
      <category term="活有所思" scheme="http://yxym.run/categories/%E6%B4%BB%E6%9C%89%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
</feed>
