<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有心有梦</title>
  
  <subtitle>YXYM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxym.run/"/>
  <updated>2020-03-19T15:52:16.498Z</updated>
  <id>http://yxym.run/</id>
  
  <author>
    <name>疯渔民</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷提笔记之第38题</title>
    <link href="http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC38%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC38%E9%A2%98/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-19T15:52:16.498Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><pre><code>　　1.     1　　2.     11　　3.     21　　4.     1211　　5.     111221</code></pre><p>1 被读作 “一个一”, 即 11。<br>11 被读作 “两个一”, 即 21。<br>21 被读作”一个二” ,  “一个一”, 即 1211</p><a id="more"></a><p>要求：</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>解题思路：</p><p>　　从题目中的信息可以知道，当我们想要求第n项的结果时，需要先知道第n-1项的字符串;想要求出第n-1项的结果时，必须先知道第n-2项的结果……以此类推，推到第1项，第一项的结果正是”1”。所以想求第n项的结果时，可以从第一项以此往后递推。解决此题，可以使用演绎法、递归法、以及使用栈。</p><p>第一种解法：使用演绎法</p><p>describe函数是针对”上一个“结果项进行分析，然后分析求出下一个结果项的样子。</p><pre><code>public String countAndSay(int n) {    String num = &quot;1&quot;;    for (int i = 0; i &lt; n - 1; i++) {        num = describe(num.toCharArray());    }    return num;}public static String describe(char[] chars){    StringBuilder string = new StringBuilder();    char ch = chars[0];    int temp = 1,i = 1;    while(i &lt; chars.length){        if (chars[i] == ch)            temp++;        else{            string.append(temp).append(chars[i-1]);            ch = chars[i];            temp = 1;        }        i++;    }    string.append(temp).append(chars[i - 1]);    return string.toString();}</code></pre><p>第二种解法：递归</p><p>递归与上面第一种解法几乎相同，唯一不同的就是上面用的是循环，而此处采用递归的方式。</p><pre><code>// 递归用法public String countAndSay4(int n) {    if (n == 1)        return &quot;1&quot;;    return describe(countAndSay4(n - 1).toCharArray());}public static String describe(char[] chars){    StringBuilder string = new StringBuilder();    char ch = chars[0];    int temp = 1,i = 1;    while(i &lt; chars.length){        if (chars[i] == ch)            temp++;        else{            string.append(temp).append(chars[i-1]);            ch = chars[i];            temp = 1;        }        i++;    }    string.append(temp).append(chars[i - 1]);    return string.toString();}</code></pre><p>第三种解法：使用栈</p><p>栈中存储的都是相同的元素，因此栈中元素个数就表示有几个栈中元素。内循环结束之后，还有进行一次append操作是为了将出现在末尾的连续数字结果进行保存。</p><pre><code>public String countAndSay3(int n){    if (n==1)        return &quot;1&quot;;    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();    StringBuilder string;    String res = &quot;1&quot;;    for (int i = 1; i &lt; n; i++) {        stack.clear();        string  = new StringBuilder();        char[] chars = res.toCharArray();        for (int j = 0;j &lt; chars.length;j++){            if (stack.isEmpty() || stack.peek() == chars[j]){                stack.push(chars[j]);            }else {                string.append(stack.size()).append(stack.peek());                stack.clear();                stack.push(chars[j]);            }        }        string.append(stack.size()).append(stack.peek());        res = string.toString();    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;　　1.     1
　　2.     11
　　3.     21
　　4.     1211
　　5.     111221&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1 被读作 “一个一”, 即 11。&lt;br&gt;11 被读作 “两个一”, 即 21。&lt;br&gt;21 被读作”一个二” ,  “一个一”, 即 1211&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第35题</title>
    <link href="http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC35%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC35%E9%A2%98/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-19T15:52:28.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><a id="more"></a><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>最直接的想法就是使用二分查找，如果有序数组中含有与target值相等的元素，直接返回对应的索引值;如果没有则在查找完毕之后，返回对应的左游标值。还有一种解法是直接遍历有序数组，遍历进行的条件是数组当前访问值小于target值同时遍历游标小于数组长度，遍历结束后，对应的遍历游标值就是应该要返回的值。</p><h4 id="第一种解法：二分查找"><a href="#第一种解法：二分查找" class="headerlink" title="第一种解法：二分查找"></a>第一种解法：二分查找</h4><p>时间复杂度为：O(logn)</p><p>我在评论中看到关于计算mid值的争议，有人说直接mid = (left + right) / 2是不安全的，可能会溢出，所以一种比较安全的写法是 mid = left + (right - left) / 2; 就好比是超过10就会发生溢出，现在有两个值，一个为6,一个为8,如果直接计算，则6+8=14&gt;10，会发生溢出，但是通过mid = left + (right - left) / 2公式进行计算 mid = 6 + (8-6)/2,就避免了这个问题，挺有道理，所以借鉴了。</p><pre><code>public int searchInsert(int[] nums, int target) {        if (nums.length == 0 || (target &lt; nums[0]))            return 0;        if (target &gt; nums[nums.length-1])            return nums.length;        if (nums.length == 1){            if (target&gt;nums[0])                return 1;            else                return 0;        }        int left = 0;        int right = nums.length - 1;        int mid = (left + right) / 2;        while (left &lt;= right){            if (nums[mid] == target)                return mid;            else if (nums[mid] &gt; target){                right = mid - 1;            }else {                left = mid + 1;            }            mid = (right + left) / 2;        }        return mid + 1;    }</code></pre><h4 id="第一种解法续：对二分查找的改进，减少循环次数"><a href="#第一种解法续：对二分查找的改进，减少循环次数" class="headerlink" title="第一种解法续：对二分查找的改进，减少循环次数"></a>第一种解法续：对二分查找的改进，减少循环次数</h4><p>这是我在题解的评论中看到有人提供的解法，思路可以借鉴，虽然运行速度并没有我的快，哈哈哈哈</p><pre><code>public int searchInsert3(int[] nums,int target){    int lo=0,hi=nums.length;    while(lo&lt;hi-1){        int mid=(lo+hi)&gt;&gt;1;        if(target&lt;nums[mid])            hi=mid;        else            lo=mid;    }    return target&lt;=nums[lo]? lo:++lo;}</code></pre><h4 id="第二种解法：暴力遍历"><a href="#第二种解法：暴力遍历" class="headerlink" title="第二种解法：暴力遍历"></a>第二种解法：暴力遍历</h4><p>超级简短，时间复杂度为O(n)</p><pre><code>public int searchInsert2(int[] nums, int target) {    int i;    for(i=0;i&lt;nums.length&amp;&amp;nums[i]&lt;target;i++);    return i;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h4&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>可变参数</title>
    <link href="http://yxym.run/2020/03/09/varargs/"/>
    <id>http://yxym.run/2020/03/09/varargs/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-03-19T11:55:34.776Z</updated>
    
    <content type="html"><![CDATA[<p>可变参数：是jdk1.5之后出现的新特性</p><ul><li><p>使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</p></li><li><p>使用格式：</p><pre><code>修饰符 返回值类型  方法名(数据类型... 变量名)</code></pre></li><li><p>可变参数的原理：</p><pre><code>可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数传递的参数个数，可以是0个（不传递），1,2,...多个</code></pre><a id="more"></a></li><li><p>可变参数的注意事项：</p><pre><code>1.一个方法的参数列表，只能有一个可变参数2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</code></pre></li></ul><p>使用示例：</p><pre><code>public static void main(String[] args) {    int i = add(10,11,12);    System.out.println(i);}/*    定义计算（0-n）个整数的和    已知：计算整数的和，数据类型已经确定int    但是参数的个数不确定，不知道要计算几个整数的和，就可以使用可变参数 */public static int add(int... arr){        System.out.println(arr); // [I@74a14482,[代表arr是数组，I代表这个数组是int类型，所以其底层是一个数组        System.out.println(arr.length); // 传递过来的参数个数        int sum = 0;        for (int i : arr) {            sum += i;        }        return sum;    }    // 定义一个方法，计算两个int整数的和    // 可变参数的特殊（终极）写法    public static void method(Object...obj){}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可变参数：是jdk1.5之后出现的新特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;修饰符 返回值类型  方法名(数据类型... 变量名)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可变参数的原理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数
传递的参数个数，可以是0个（不传递），1,2,...多个&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义异常</title>
    <link href="http://yxym.run/2020/03/08/ownDefineException/"/>
    <id>http://yxym.run/2020/03/08/ownDefineException/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-19T11:54:37.042Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，根据自己业务的异常情况来定义异常类。</p><p>异常类如何定义：</p><ul><li><p>自定义一个编译期异常：自定义类并继承于<code>java.lang.Exception</code></p></li><li><p>自定义一个运行期异常：自定义类并继承于<code>java.lang.RuntimeException</code></p><a id="more"></a><p>格式：</p><p>   public class XXXException extends Exception | RuntimeException{</p><pre><code>添加一个空参数的构造器添加一个带异常信息的构造方法</code></pre><p>   }<br>注意：</p><p>   1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类<br>   2.自定义异常类，必须得继承Exception或者RuntimeException</p><pre><code>继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</code></pre></li></ul><h4 id="自定义异常类练习："><a href="#自定义异常类练习：" class="headerlink" title="自定义异常类练习："></a>自定义异常类练习：</h4><p>1.先定义一个异常类：</p><pre><code>public class RegisterException extends Exception{    public RegisterException() {        super();    }    // 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，    // 方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息    public RegisterException(String message){        super(message);    }}</code></pre><p>2.调用</p><pre><code>public class Demo04RegisterException {    static String[] usernames = {&quot;张三&quot;};    public static void main(String[] args) throws RegisterException {        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入您要注册的用户名：&quot;);        String username = sc.next();        checkUsername(username);    }    public static void checkUsername(String username) throws RegisterException {        for (String s : usernames) {            if (s.equals(username)){                throw  new RegisterException(&quot;该用户名已经被注册!&quot;);            }        }        System.out.println(&quot;注册成功！&quot;);    }}</code></pre><p>上面的处理异常的方式是抛出，下面采用捕获异常的方式来处理异常</p><pre><code>public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入您要注册的用户名：&quot;);    String username = sc.next();    checkUsername(username);}public static void checkUsername(String username){    for (String s : usernames) {        if (s.equals(username)){            try {                throw  new RegisterException(&quot;该用户名已经被注册!&quot;);            } catch (RegisterException e) {                e.printStackTrace();                return; //结束方法，为了避免之后的代码还能被执行            }        }    }    System.out.println(&quot;注册成功！&quot;);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，根据自己业务的异常情况来定义异常类。&lt;/p&gt;
&lt;p&gt;异常类如何定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自定义一个编译期异常：自定义类并继承于&lt;code&gt;java.lang.Exception&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义一个运行期异常：自定义类并继承于&lt;code&gt;java.lang.RuntimeException&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="http://yxym.run/2020/03/08/throwable/"/>
    <id>http://yxym.run/2020/03/08/throwable/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-19T11:59:28.645Z</updated>
    
    <content type="html"><![CDATA[<p>异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p><p>在Java语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常。Java处理异常的方式是中断处理。</p><a id="more"></a><p>异常的根类是<code>java.lang.Throwable</code>，其下有两个子类，<code>java.lang.Error</code>与<code>java.lang.Exception</code></p><p>Throwable体系:</p><ul><li><p>Error:严重错误，无法通过处理的错误只能事先避免。必须修改源代码，程序才能继续执行。</p></li><li><p>Exception:表示异常，异常产生后可以通过代码的方式纠正，使得程序继续运行，是必须要处理的。</p><pre><code>Exception异常主要分为：  编译期异常，进行编译（写代码）java程序出现的异常。RuntimeException：运行期异常，java程序运行过程中出现的问题。</code></pre></li></ul><h4 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h4><p>Java异常处理的五个关键字：<code>try、catch、finally、throw、throws</code></p><p><strong>1、抛出异常throw</strong></p><p>该关键字用于抛出一个指定的异常对象，抛出一个异常具体的操作如下：</p><pre><code>1、创建一个异常对象，封装一些提示信息（信息可以自己编写）2、需要将这个异常对象告知调用者，通过throw关键字即可将这个异常对象传递到调用者处。</code></pre><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><p>使用格式：</p><pre><code>throw new 异常类名(参数);例如：    throw new NullPointerException(&quot;需要访问的arr数组不存在&quot;);</code></pre><p>注意：</p><pre><code>1.throw关键字必须写在方法的内部2.throw关键字后边new的对象必须是Exception或者Exception的子类对象3.throw关键字抛出指定的异常对象，那就必须处理这个异常对象        throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，可以不处理，默认交给JVM（打印异常对象，中断程序）        throw关键字后边创建的是编译异常（写代码的时候报错），必须处理这个异常，要么throws，要么try...catch    </code></pre><h4 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h4><p>对传递过来的参数进行合法性判断，判断是否为null，可以使用Objects中的静态方法：</p><pre><code>public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象是不是null源码：    public static &lt;T&gt; T requireNonNull(T obj){        if (obj == null)            throw new NullPointerException();        return obj;    }</code></pre><p>使用示例：</p><pre><code>public static void main(String[] args) {    int[] arr = null;    getElement(arr,5);}private static int getElement(int[] arr,int index) {    //if (arr == null)    //      throw new NullPointerException(&quot;传递的数组值是null&quot;);    Objects.requireNonNull(arr,&quot;传递的数组值是null&quot;);    if (index &lt; 0||index&gt;=arr.length)        throw new ArrayIndexOutOfBoundsException(&quot;传递的索引超出了数组的使用范围&quot;);    int ele = arr[index];    return ele;}</code></pre><p><strong>2、声明异常throws</strong><br>将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。</p><p>关键字throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常。</p><p>声明异常的格式：</p><pre><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2...{ }</code></pre><p>throws关键字：异常处理的第一种方式，交给别人处理</p><p>作用：</p><ul><li>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</li><li>可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理</li></ul><pre><code>使用格式：在方法声明时使用    修饰符 返回值类型 方法名(参数) throws AAAException,BBBException...{        throw new AAAException(&quot;产生原因&quot;);        throw new BBBException(&quot;产生原因&quot;);     }</code></pre><p>注意：</p><ul><li><p>throws关键字必须写在方法声明处</p></li><li><p>throws关键字后边声明的异常必须是Exception或者是Exception的子类</p></li><li><p>方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常</p><pre><code>如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可</code></pre></li><li><p>调用了一个声明抛出异常的方法，就必须处理得处理声明的异常</p><pre><code>要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM要么使用try...catch自己处理异常</code></pre></li></ul><p>示例代码：</p><pre><code>public static void main(String[] args) throws IOException {    readFile(&quot;&quot;);}/*    FileNotFoundException 是编译异常 */public static void readFile(String fileName) throws IOException {    if (!fileName.equals(&quot;c:\\a.text&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>使用格式：</p><pre><code> try{        可能产生异常的代码    }catch(定义一个异常变量，用来接收try中抛出的异常对象){        异常的处理逻辑，异常对象之后，怎么处理异常对象        一般在工作中，会把异常的信息记录到一个日志中    }    ...    catch(异常类名 变量名){}</code></pre><p>注意：</p><ul><li>try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象</li><li>如果try中产生了异常，那么就会执行catch中异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码</li><li>如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try…catch之后的代码</li></ul><p>示例代码：</p><pre><code>public static void main(String[] args) {    try {        readFile(&quot;d:\\a.tx&quot;);    } catch (IOException e) {        System.out.println(&quot;文件的后缀不是.txt&quot;);    }    System.out.println(&quot;后续代码&quot;);}public static void readFile(String fileName) throws IOException {    if (!fileName.endsWith(&quot;.txt&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="Throwable的三个异常处理的方法"><a href="#Throwable的三个异常处理的方法" class="headerlink" title="Throwable的三个异常处理的方法"></a>Throwable的三个异常处理的方法</h4><p>1.<code>String getMessage()</code>:返回此throwable的简短描述</p><p>2.String toString() : 返回此throwable的详细消息字符串</p><p>3.printStackTrace()</p><pre><code>public static void main(String[] args) {    try {        readFile(&quot;d:\\a.tx&quot;);    } catch (IOException e) {        System.out.println(e.getMessage());        /*            传递的文件路径不是c:\a.text         */        //System.out.println(e.toString()); //重写了Object类的toString方法        //System.out.println(e);        /*            java.io.FileNotFoundException: 传递的文件路径不是c:\a.text         */        //e.printStackTrace();        /*        java.io.FileNotFoundException: 传递的文件路径不是c:\a.text            at Throwable.Demo03TryCatch.readFile(Demo03TryCatch.java:40)            at Throwable.Demo03TryCatch.main(Demo03TryCatch.java:26)         */    }    System.out.println(&quot;后续代码&quot;);}public static void readFile(String fileName) throws IOException {    if (!fileName.endsWith(&quot;.txt&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>有些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><pre><code>try...catch...finally</code></pre><p>注意：</p><p>1.finally不能单独使用;</p><p>2.finally一般用于资源释放，无论程序是否出现异常，最后都要资源释放。</p><h4 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h4><ul><li>多个异常使用捕获该如何处理呢？</li></ul><p>1.多个异常分别处理</p><pre><code>try{    ...}catch{    ...}try{    ...}catch{    ...}try{    ...}catch{    ...}</code></pre><p>2.多个异常一次捕获、多次处理</p><pre><code>try{    ...}catch(){    ...}catch(){    ...}...</code></pre><p>一个try多个catch注意事项：</p><pre><code>try中如果出现了异常对象，会把异常对象抛出给catch处理，抛出的异常对象，会从上到下依次赋值给catch中定义的异常变量。catch里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上边，否则就会报错</code></pre><p>3.多个异常一次捕获一次处理</p><pre><code>try{    ...}catch(){    ...}try中含有多个异常，在catch可以一次性捕获try中的多个异常，在catch中的异常对象变量要能同时接收多个异常对象</code></pre><ul><li>运行时异常被抛出可以不处理，即不捕获也不声明抛出。默认会给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再来继续执行程序。</li><li>如果finally中有return语句，永远返回finally中的结果，避免该情况。</li><li>如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</li><li>父类方法没有抛出异常，子类重写父类方法时也不可以抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li><li>在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。&lt;/p&gt;
&lt;p&gt;在Java语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常。Java处理异常的方式是中断处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>System类</title>
    <link href="http://yxym.run/2020/03/07/systemClass/"/>
    <id>http://yxym.run/2020/03/07/systemClass/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-19T11:53:35.824Z</updated>
    
    <content type="html"><![CDATA[<p>该类位于java.lang包中，可以直接使用，不用导包。</p><p>System类中提供了大量的静态方法，可以获取与系统相关的信息或系统操作级操作，在System类的<br>API文档中，常用的方法：</p><a id="more"></a><p>1、currentTimeMillis</p><pre><code>public static long currentTimeMillis()</code></pre><p>返回当前时间（以毫秒为单位）。 请注意，虽然返回值的时间单位为毫秒，但该值的粒度取决于底层操作系统，并且可能较大。<br>例如，许多操作系统以几十毫秒为单位测量时间。</p><p>该方法可以用来测试程序的运行效率。</p><p>2、arraycopy</p><pre><code>public static void arraycopy(Object src,                         int srcPos,                         Object dest,                         int destPos,                         int length)</code></pre><p>将指定源数组中的数组从指定位置复制到目标数组的指定位置。</p><p>参数</p><pre><code>src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目的地数据中的起始位置。length - 要复制的数组元素的数量。</code></pre><p>代码实例：</p><pre><code>public static void demo02(){    int[] src = {1,2,3,4,5,6};    int[] dest = {6,7,8,9,10,11};    System.out.println(&quot;复制前：&quot;+ Arrays.toString(dest));    System.arraycopy(src,0,dest,0,3);    System.out.println(&quot;复制后：&quot;+Arrays.toString(dest));    /*        复制前：[6, 7, 8, 9, 10, 11]        复制后：[1, 2, 3, 9, 10, 11]    */}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类位于java.lang包中，可以直接使用，不用导包。&lt;/p&gt;
&lt;p&gt;System类中提供了大量的静态方法，可以获取与系统相关的信息或系统操作级操作，在System类的&lt;br&gt;API文档中，常用的方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea导入Java se程序无法正常run</title>
    <link href="http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:31.981Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。</p><p>程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。</p><a id="more"></a><ul><li>首先点击Idea左上角的“File”,然后找到“Project Structure ”配置选项</li><li>然后点击“Project setting”选项下的Project选项，设置JDK的版本，并且选择Project language level，因为我的Jdk版本是1.8，所以这里我选的是“Lambdas，type annotation etc”；然后在最下面设置项目的路径，即项目的完整工作空间路径。</li><li>点击“Modules”选项，选择右边方框里的蓝色“Sources”选项，将项目种的src文件设置为源代码文件夹，点击应用，最后点击ok即可运行。</li></ul><h3 id="关于Project-language-level"><a href="#关于Project-language-level" class="headerlink" title="关于Project language level"></a>关于Project language level</h3><p>我们应该知道 Java JDK 在每个新版本都会有其新特性，而新版本一般也会向下兼容旧版本的特性，在IntelliJ IDEA中 对这些 JDK 的新特性是这样介绍的：</p><ul><li>JDK 6 的新特性：@Override in interfaces</li><li>JDK 7 的新特性：Diamonds，ARM，multi-catch etc.</li><li>JDK 8 的新特性：Lambdas，type annotation etc.</li><li>JDK 9 的新特性：Jigsaw project etc.</li></ul><p>其中，当我们使用某一个版本的Jdk的时候，我们只能向下兼容，否则运行程序时是会运行不了的。比如我的Jdk的版本是1.8，那么我只能选择8及以下的language level。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。&lt;/p&gt;
&lt;p&gt;程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践问题总结" scheme="http://yxym.run/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Python的with关键字</title>
    <link href="http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:18.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、上下文管理器的概念"><a href="#1、上下文管理器的概念" class="headerlink" title="1、上下文管理器的概念"></a>1、上下文管理器的概念</h4><p><strong>上下文管理协议（Context Management Protocol）：</strong></p><pre><code>包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 </code></pre><p><strong>上下文管理器（Context Manager）</strong>：</p><pre><code>支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 </code></pre><a id="more"></a><p><strong>运行时上下文（runtime context）：</strong></p><pre><code>由上下文管理器创建，通过上下文管理器的 __enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。 </code></pre><p><strong>上下文表达式（Context Expression）</strong>：</p><pre><code>with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。 </code></pre><p><strong>语句体（with-body）</strong>：</p><pre><code>with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行__exit__() 方法。</code></pre><h4 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h4><p>with表达式其实是try-finally的简写形式。但是又不是全相同。</p><p><strong>格式</strong></p><pre><code>with context [as var]:    pass</code></pre><p>context 是一个表达式，返回的就是支持上下文管理协议的对象，var这个变量用来保存context表达式返回的对象，可以有单个或者多个返回值。</p><pre><code>with open(&apos;test1.txt&apos;) as f:        f.read()</code></pre><p> 表达式open(‘test1.txt’)返回的是一个    _io.TextIOWrapper 类型的对象变量，用f来保存，在with语句块中就可以使用这个变量操作文件。执行with这个结构之后。f会自动关闭，相当于自带了一个finally。</p><p> 注意：with本身并没有异常捕获的功能，但是如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p> 对于自定义的类想要正确使用with关键字，必须实现上述的几个方法才可以：</p><pre><code>class Sample:   def __enter__(self):           pass      def __exit__(self, type, value, trace):           pass</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、上下文管理器的概念&quot;&gt;&lt;a href=&quot;#1、上下文管理器的概念&quot; class=&quot;headerlink&quot; title=&quot;1、上下文管理器的概念&quot;&gt;&lt;/a&gt;1、上下文管理器的概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;上下文管理协议（Context Management Protocol）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;上下文管理器（Context Manager）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python基础知识笔记" scheme="http://yxym.run/categories/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder类</title>
    <link href="http://yxym.run/2020/03/06/stringBuilderClass/"/>
    <id>http://yxym.run/2020/03/06/stringBuilderClass/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-19T11:52:58.073Z</updated>
    
    <content type="html"><![CDATA[<p>又称为字符串缓冲区</p><p>对于String类：</p><ul><li>字符串是常量，它们的值在创建之后不能更改。</li><li>字符串底层是一个被final关键字修饰的数组，不能改变，是一个常量。</li></ul><pre><code>private final byte[] value;  </code></pre><a id="more"></a><p>进行字符串的相加，内存中就会有多个字符串，占用空间多，效率低下。比如：</p><pre><code>String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; = &quot;abc&quot;其运算过程如下：首先: 内存中有三个字符串 &quot;a&quot; &quot;b&quot; &quot;c&quot;然后: &quot;a&quot; + &quot;b&quot; 增加了一个字符串&quot;ab&quot;再然后: &quot;ab&quot; + &quot;c&quot; 增加了一个字符串&quot;abc&quot;此时内存中就会有5个字符串，会造成程序的效率低下，空间浪费</code></pre><p>对于字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），<br>底层也是一个数组，但是没有被final修饰，可以改变长度。</p><pre><code>byte[] value = new byte[16];</code></pre><p>StringBuilder在内存中始终是一个数组，占用空间少，效率高，初始容量为16字节。</p><p>如果超出了StringBuilder的容量，会自动扩容。    </p><p>StringBuilder类中的append方法：</p><pre><code>public StringBuilder append(...)</code></pre><p>添加任意类型数据的字符串形式并返回当前对象自身。</p><pre><code>public static void main(String[] args) {    StringBuilder bu1 = new StringBuilder();    StringBuilder bu2 = new StringBuilder(&quot;abc&quot;);    System.out.println(bu2);    // 使用append方法往StringBuilder中添加数据    // append方法返回的是this，调用方法的对象bu1,this==bu1    StringBuilder bu3 = bu1.append(&quot;acb&quot;); // 把bu1的地址赋值给了bu3    System.out.println(bu3);    System.out.println(bu1);    System.out.println(bu3==bu1); // 比较的是地址    // 使用append方法无需接收返回值    //append可以添加任意数据类型的数据    /*        链式编程，方法返回值是一个对象，可以继续调用方法    */    bu1.append(&quot;abc&quot;).append(1).append(8.8).append(&apos;中&apos;).append(bu2);    System.out.println(bu3);}</code></pre><p>StringBuilder类中的toString方法：</p><p>StringBuilder -&gt; String:使用StringBuilder的toString方法</p><pre><code>public String toString():将当前StringBuilder对象转换为String对象。</code></pre><p>String -&gt; StringBuilder：使用StringBuilder的构造方法</p><pre><code>String  s = &quot;str&quot;;StringBuilder sbu = new StringBuilder(str);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又称为字符串缓冲区&lt;/p&gt;
&lt;p&gt;对于String类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串是常量，它们的值在创建之后不能更改。&lt;/li&gt;
&lt;li&gt;字符串底层是一个被final关键字修饰的数组，不能改变，是一个常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;private final byte[] value;  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Set接口</title>
    <link href="http://yxym.run/2020/03/05/set/"/>
    <id>http://yxym.run/2020/03/05/set/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2020-03-19T12:02:24.467Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Set</code>接口继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对Collection<br>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。<code>Set</code>接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。</p><a id="more"></a><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址）</p><p>在<code>Object</code>类有一个方法，可以获取对象的哈希值。</p><pre><code>int hashCode() 返回该对象的哈希码值</code></pre><p><code>hashCode</code>方法的源码：</p><pre><code>public native int hashCode();native：代表该方法调用的是本地操作系统的方法</code></pre><p>实例：</p><pre><code>public static void main(String[] args) {    // Person类继承了Object类，所以可以使用Object类的hashCode方法    Person p1 = new Person();    int h1 = p1.hashCode();    System.out.println(h1); // 1956725890    Person p2 = new Person();    int h2 = p2.hashCode();    System.out.println(h2); // 356573597    /*        toString方法的源码：            return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());     */    System.out.println(p1); // Set.Person@74a14482    System.out.println(p2); // Set.Person@1540e19d    /*        对象的地址值用的就是hashcode值，是一个十进制整数     */    System.out.println(p1==p2); // false,即使将hashcode值改成相同的，但是实际的物理地址也不相同    /*        String类的哈希值            String类重写Object类的hashCode方法     */    /*        String类重写的hashCode方法源码：    public int hashCode() {        int h = hash;        if (h == 0 &amp;&amp; value.length &gt; 0) {            char val[] = value;            for (int i = 0; i &lt; value.length; i++) {                h = 31 * h + val[i];            }            hash = h;        }        return h;    }     */    String s1 = new String(&quot;abc&quot;);    String s2 = new String(&quot;abc&quot;);    // s1与s2的哈希值是相同的    System.out.println(s1.hashCode());    System.out.println(s2.hashCode());}</code></pre><h4 id="HashSet集合存储数据的结构"><a href="#HashSet集合存储数据的结构" class="headerlink" title="HashSet集合存储数据的结构"></a>HashSet集合存储数据的结构</h4><p>jdk1.8版本之前：哈希表=数组+链表</p><p>jdk1.8版本之后：<br>    哈希表 = 数组 + 链表  /<br>    哈希表 = 数组 + 红黑树（提高查询的速度）</p><p>哈希表的特点：速度快</p><p>哈希表结构分析：</p><ul><li><p>数组结构：把元素进行了分组，（相同哈希值的元素是一组）</p></li><li><p>链表/红黑树结构把相同哈希值的元素连接到一起</p></li></ul><p>数据存储到集合中的过程：</p><ul><li>先计算元素的哈希值，此哈希值就是该元素在数组中的存储位置</li><li>将元素挂到数组结构中对应的哈希值位置</li><li>如果发生哈希冲突（元素不同但是哈希值相同），将它们挂在相同的数组结构对应的哈希值位置下，形成一个链表结构</li><li>如果链表结构中的元素数量超过了8位，那么就会把链表转为红黑树，目的就是为了提高查询速度</li></ul><h4 id="HashSet存储元素不重复的原理"><a href="#HashSet存储元素不重复的原理" class="headerlink" title="HashSet存储元素不重复的原理"></a>HashSet存储元素不重复的原理</h4><p>Set集合不允许重复存储元素的原理：</p><pre><code>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否重复</code></pre><p>注意，Set集合存储元素不重复的元素：<br>    前提是存储的元素必须重写hashCode方法和equals方法</p><p>具体案例分析：</p><pre><code>public static void main(String[] args) {    //创建HashSet集合对象    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();    String s1 = new String(&quot;abc&quot;);    String s2 = new String(&quot;abc&quot;);    /*        set.add(s1);        1. add方法会调用是s1的hashCode方法，计算字符串“abc”的哈希值，哈希值是一个十进制整数96354        然后会在集合中查找有没有96354这个哈希值的元素，发现没有，就会将s1存储到集合中        set.add(s2);        2. add方法会调用是s2的hashCode方法，计算字符串“abc”的哈希值，哈希值是一个十进制整数96354        然后会在集合中查找有没有96354这个哈希值的元素，发现有（哈希冲突）。s2会调用equals方法和哈希值相同的元素进行比较，        s2.equals(s1)，返回true        两个元素的哈希值相同，equals方法返回true，认定两个元素相同，就不会把s2存储到集合中        set.add(&quot;重地&quot;);        3. add方法会调用是“重地”的hashCode方法，计算字符串“重地”的哈希值，哈希值是一个十进制整数1179395        然后会在集合中查找有没有1179395这个哈希值的元素，发现没有，就会将“重地”存储到集合中        set.add(&quot;通话&quot;);        4. add方法会调用是“通话”的hashCode方法，计算字符串“通话”的哈希值，哈希值是一个十进制整数1179395        然后会在集合中查找有没有1179395这个哈希值的元素，发现有(哈希冲突)，“通话”会调用equals方法和哈希值相同的元素进行比较，        两个元素的哈希值相同，equals方法返回false，认定两个元素不同，就会把该字符串存储到集合     */    set.add(s1);    set.add(s2);    set.add(&quot;重地&quot;);    set.add(&quot;通话&quot;);    set.add(&quot;abc&quot;);    System.out.println(set);}</code></pre><h4 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，必须重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p>实例：</p><p>定义一个Person类，含有属性name和age，同一个人的要求是必须是名字和年龄都相同，将其存放进HashSet必须重写hashcode和equals方法</p><pre><code>public class Person extends Object {    // 重写hashcode方法    private String name;    private int age;    public Person(){}    public Person(String name,int age){        this.name = name;        this.age = age;    }    public int getAge() {        return age;    }public void setAge(int age) {    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}@Overridepublic int hashCode() {    return Objects.hash(name, age);}}</code></pre><p>在主类的主方法中声明一个Person对象，并且进行存入实验：</p><pre><code>public static void main(String[] args) {    // 同名同年龄视为同一个人    // 创建HashSet集合存储Person    HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();    Person p1 = new Person(&quot;xiaomeinv&quot;,18);    Person p2 = new Person(&quot;xiaomeinv&quot;, 18);    Person p3 = new Person(&quot;xiaomeinv&quot;, 19);    set.add(p1);    set.add(p2);    set.add(p3);    System.out.println(set);    System.out.println(p1.hashCode()); // 1583688505    System.out.println(p2.hashCode()); // 1583688505    System.out.println(p1==p2); // false，物理地址不同，所以直接比较也是不同的    System.out.println(p1.equals(p2)); // true}</code></pre><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><pre><code>java.util.LinkedHashSet集合 extends HashSet集合</code></pre><p>LinkedHashSet集合特点：</p><pre><code>底层是一个哈希表（数组+链表/红黑树）+链表：多了一条链表（记录元素的存储顺序），保证元素有序</code></pre><p>实例代码：</p><pre><code>public static void main(String[] args) {    HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();    set.add(&quot;www&quot;);    set.add(&quot;abc&quot;);    set.add(&quot;abc&quot;);    set.add(&quot;itcast&quot;);    System.out.println(set); //无序的，并且不允许重复    LinkedHashSet&lt;Object&gt; linked = new LinkedHashSet&lt;&gt;();    linked.add(&quot;www&quot;);    linked.add(&quot;abc&quot;);    linked.add(&quot;itcast&quot;);    System.out.println(linked); // 有序的，不允许重复}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.Set&lt;/code&gt;接口继承自&lt;code&gt;Collection&lt;/code&gt;接口，它与&lt;code&gt;Collection&lt;/code&gt;接口中的方法基本一致，并没有对Collection&lt;br&gt;接口进行功能上的扩充，只是比&lt;code&gt;Collection&lt;/code&gt;接口更加严格了。&lt;code&gt;Set&lt;/code&gt;接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="http://yxym.run/2020/03/04/objectClass/"/>
    <id>http://yxym.run/2020/03/04/objectClass/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-19T12:04:07.519Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.lang.Object</code>,所有类的父类，它中描述的所有方法子类都可以使用。</p><p>java.lang包中的类可以直接引用，无需导包</p><a id="more"></a><h4 id="Object类的toString方法"><a href="#Object类的toString方法" class="headerlink" title="Object类的toString方法"></a>Object类的toString方法</h4><p>看一个类是否重写了<code>toString</code>，直接打印这个类的对象即可，如果没有重写<code>toString</code>方法，那么打印的是对象的在堆内存中的地址值</p><pre><code>Random a = new Random(); System.out.println(a); //java.util.Random@1540e19dArrayList array = new ArrayList();array.add(1);array.add(2);System.out.println(array); //[1, 2]</code></pre><p>可见Random类并没有重写ToString方法，但是ArrayList类重写了该方法。</p><h4 id="Object类的equals方法"><a href="#Object类的equals方法" class="headerlink" title="Object类的equals方法"></a>Object类的equals方法</h4><p>源码:</p><pre><code>public boolean equals(Object obj) {    return (this == obj);}</code></pre><p>参数：</p><ul><li><p>Object obj：可以传递任意的对象</p></li><li><p>== 比较运算符，返回的是一个布尔值：true，false</p></li><li><p>对于：</p><p>  基本数据类型：比较的是值</p><p>  引用数据类型：比较的是两个对象的地址值</p></li></ul><p>this是谁？</p><p>哪个对象调用的方法，方法中的this就是指的那个对象。</p><p>obj是谁？</p><p>传递过来的参数对象。</p><p>Object类的equals方法，默认比较的是两个对象的地址值，这是没有意义的，所以我们要重写equals方法，<br>比较两个对象的属性。</p><p>但是也会存在一些问题：即隐含着一个多态，多态存在弊端，即无法使用子类特有的内容（属性和方法）</p><p>解决的方案就是：可以使用强制类型转换，将父类引用向下转型成子类引用</p><p>重写某个自定义类的equals方法：</p><pre><code>public boolean equals(Object obj) {    // 增加一个判断，如果传递的参数是本身，则直接返回true，可以提高程序的效率    if (obj == this)        return true;    // 增加一个判断，传递的参数obj如果是null，直接返回false，提高程序的效率    if (obj == null)        return false;    // 增加一个判断，防止出现类型转换异常    if (obj instanceof Person){        //使用向下转型，将obj转换为Person类型        Person p = (Person)obj;        return p.name.equals(this.name) &amp;&amp; this.age==p.age;    }    return false;}</code></pre><p>IDEA重写的自定义类的equals方法：</p><pre><code>public boolean equals(Object o) {    if (this == o) return true;    // getClass() != o.getClass() 使用反射技术，判断o是否是Person类型，等价于obj instanceof Person    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}</code></pre><h4 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h4><p>使用IDEA自动重写的equals代码中，使用到了java.util.Objects类，这个类是JDK7新增加的一个Objects工具类，<br>它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），<br>用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象。</p><p>在比较两个对象的时候，Object容易抛出空指针异常，但是Objects类中的equals方法优化了这个问题，其源代码如下：</p><pre><code>public static boolean equals(Object a, Object b) {    return (a == b) || (a != null &amp;&amp; a.equals(b));}</code></pre><p>null是不能调用方法的，否则就会抛出空指针异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;,所有类的父类，它中描述的所有方法子类都可以使用。&lt;/p&gt;
&lt;p&gt;java.lang包中的类可以直接引用，无需导包&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Map集合</title>
    <link href="http://yxym.run/2020/03/04/map/"/>
    <id>http://yxym.run/2020/03/04/map/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:44.363Z</updated>
    
    <content type="html"><![CDATA[<p>将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值。</p><pre><code>public interface Map&lt;K,V&gt;</code></pre><p>K代表键的类型，V代表值的类型</p><p>Collection接口定义了单列集合规范，每次存储一个元素。</p><p>Map接口定义了双列集合的规范，每次存储一对儿元素。</p><a id="more"></a><p>Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</p><p>Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找到对应的值。</p><p>Map集合的特点：</p><ul><li>Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）</li><li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>Map集合中的元素，key是不允许重复的，value是可以重复的</li><li>Map集合中的元素，key和value是一一对应的</li></ul><h4 id="Map常用集合之HashMap-lt-K-V-gt"><a href="#Map常用集合之HashMap-lt-K-V-gt" class="headerlink" title="Map常用集合之HashMap&lt;K,V&gt;"></a>Map常用集合之HashMap&lt;K,V&gt;</h4><p>基于哈希表的Map接口的实现。允许使用null值和null键，此类不保证映射的顺序。</p><p>不同步，多线程。</p><p>HashMap集合的特点：</p><ul><li>HashMap集合底层是哈希表：查询速度特别快。（JDK1.8之后，结构是数组+单向链表/红黑树（链表长度超过8））</li><li>hashMap是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li></ul><h4 id="HashMap常用集合之LinkedHashMap"><a href="#HashMap常用集合之LinkedHashMap" class="headerlink" title="HashMap常用集合之LinkedHashMap"></a>HashMap常用集合之LinkedHashMap</h4><pre><code>java.util.LinkedHashMap&lt;k,v&gt; extends HashMap&lt;k,v&gt;</code></pre><p>LinkedHashMap的特点：</p><ul><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储元素和取出元素的顺序是一致的</li></ul><h4 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h4><p>1.<code>public V put(K key,V value)</code>:把指定的键与指定的值添加到Map集合中</p><ul><li>返回值：v</li><li>存储键值对的时候，key不重复，返回值V是null</li><li>存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值</li></ul><pre><code>private static void show01() {    // 创建Map集合对象，多态    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();    String v1 = map.put(&quot;lichen&quot;, &quot;fanbingbing&quot;);    System.out.println(v1);    String v2 = map.put(&quot;lichen&quot;, &quot;fanb&quot;);    System.out.println(v2);    System.out.println(map); //{lichen=fanb}    map.put(&quot;lengfeng&quot;, &quot;longxiaoyun&quot;);    map.put(&quot;yangguo&quot;,&quot;lalala&quot;);    map.put(&quot;sdhajsd&quot;,&quot;lalala&quot;);    System.out.println(map);}</code></pre><p>2.<code>public V remove(Object key)</code> : 把指定的键对应的键值对元素在Map集合中删除，返回被删除元素的值</p><ul><li>返回值：V</li><li>key存在，V返回被删除的值</li><li>key不存在，V返回null</li></ul><pre><code>private static void show02() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    System.out.println(map);    Integer v1 = map.remove(&quot;zaliying&quot;);    System.out.println(&quot;v1: &quot;+v1); // v1: 168    System.out.println(map);    Integer v2 = map.remove(&quot;zaliying&quot;);    System.out.println(&quot;v2: &quot;+v2); // v1: null    // 移除一个集合中没有的元素，返回值赋值给int类型而不是Integer类型的变量    // 相当于自动拆箱，但是打印输出时，会发生一个空指针异常，复制给其包装类就不会出现这个问题    int v3 = map.remove(&quot;zaliying&quot;);}</code></pre><p>3.<code>public V get(Obejct key)</code>: 根据指定的键，在Map集合中获取对应的值</p><p>返回值：</p><ul><li>key存在，返回对应的value值</li><li>key不存在，返回null</li></ul><pre><code>private static void show03() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    Integer v1 = map.get(&quot;zaliying&quot;);    System.out.println(v1); // 168    Integer v2 = map.get(&quot;dada&quot;);    System.out.println(v2); // null}</code></pre><p>4.<code>boolean containsKey(Object key)</code>: 判断集合中是否包含指定的键</p><ul><li>包含返回true，不包含返回false</li></ul><pre><code>private static void show04() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    boolean b1 = map.containsKey(&quot;zaliying&quot;);    System.out.println(b1);  // true    boolean sa = map.containsKey(&quot;sa&quot;);    System.out.println(sa); // false}</code></pre><h4 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h4><p>键找值方式：通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><p>1.获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</p><p>2.遍历键的Set集合，得到每一个键</p><p>3.根据键，获取键对应的值</p><p>Map集合的第一种遍历方式：通过键找值的方式</p><pre><code>Map集合中的方法：    Set&lt;K&gt; keySet() 返回此映射中包含的键的Set视图实现步骤：    1.使用Map集合中的方法keySet()，把Map集合所有的key取出来，存储到一个Set集合中    2.遍历Set集合，获取Map集合中的每一个key    3.通过Map集合中的方法get(key),通过key找到value</code></pre><p>具体的代码实例：</p><pre><code>public static void main(String[] args) {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    Set&lt;String&gt; set = map.keySet();    Iterator&lt;String&gt; it = set.iterator();    while (it.hasNext()){        System.out.println(map.get(it.next()));    }    for (String s : set) {        System.out.println(map.get(s));    }}</code></pre><p>遍历set的方式有两种，一种是使用迭代器，另一种是使用增强for循环。</p><h4 id="Entry-lt-K-V-gt-键值对对象"><a href="#Entry-lt-K-V-gt-键值对对象" class="headerlink" title="Entry&lt;K,V&gt;键值对对象"></a>Entry&lt;K,V&gt;键值对对象</h4><p>在Map接口中有一个内部接口Entry</p><p>作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)</p><p>Map集合的第二种遍历方式：使用Entry对象遍历</p><pre><code>Map集合中的方法：    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图实现步骤：    1.使用Map集合中的entrySet()，把Map集合中多个Entry对象取出来，存储到一个Set集合中    2.遍历Set集合，获取每一个Entry对象    3.使用Entry对象中的方法getKey()和getValue()获取键与值</code></pre><p>具体的代码实例：</p><pre><code>public static void main(String[] args) {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    // Map.Entry 外部类.内部类的方式访问    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();    while (it.hasNext()){        Map.Entry&lt;String, Integer&gt; entry = it.next();        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key+&quot;=&quot;+value);    }    for (Map.Entry&lt;String, Integer&gt; entry : set) {        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key+&quot;=&quot;+value);    }}</code></pre><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>此类实现了一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用作键或者值。</p><p>同步的，单线程。</p><pre><code>java.util.Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt;Hashtable：底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快HashMap集合（之前需的所有的集合）：可以存储null值，null键Hashtable集合，不能存储null值，null键1.2版本之后，被更先进的集合取代了Hashtable的子类Properties依然活跃在历史舞台Properties集合是一个唯一和IO流相结合的集合</code></pre><p>如果往Hashtable集合中的键或者值存入null，会发生空指针异常：<code>NullPointerException</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Map&amp;lt;K,V&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;K代表键的类型，V代表值的类型&lt;/p&gt;
&lt;p&gt;Collection接口定义了单列集合规范，每次存储一个元素。&lt;/p&gt;
&lt;p&gt;Map接口定义了双列集合的规范，每次存储一对儿元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Iterator</title>
    <link href="http://yxym.run/2020/03/03/IteratorClass/"/>
    <id>http://yxym.run/2020/03/03/IteratorClass/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:10.273Z</updated>
    
    <content type="html"><![CDATA[<p>迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断;<br>如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><a id="more"></a><p>Iterator接口的常用方法：</p><pre><code>boolean hasNext() 如果仍有元素可以迭代，则返回 true    判断集合中还有没有下一个元素，有就fanhuitrue没有就返回falseE next() 返回迭代的下一个元素    取出集合中的下一个元素</code></pre><p>Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方式比较特殊<br>Collention接口中有一个方法，叫iterator(),这个方法返回的就是迭代器的实现类对象。</p><pre><code>Iterator&lt;E&gt; iterator() 返回在此collection的元素上进行迭代的迭代器</code></pre><p><strong>迭代器的使用步骤：</strong></p><p>1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</p><p>2、使用Iterator接口中的方法hasNext判断还有没有下一个元素</p><p>3、使用Iterator接口中的方法next取出集合中的下一个元素</p><p>实现代码：</p><pre><code>public static void main(String[] args) {    Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();    coll.add(&quot;asd&quot;);    coll.add(&quot;qwe&quot;);    coll.add(&quot;csc&quot;);    /*        1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）        注意：Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型     */    // coll.iterator() 获取迭代器的实现类对象，并且会把指针（索引）指向集合的-1索引    Iterator&lt;String&gt; it = coll.iterator();    // hasNext() 判断集合中还有没有下一个元素    while (it.hasNext()){        // next()方法做了两件事情，第一件是取出下一个元素，第二件是把指针向后移动一位        System.out.println(it.next());    }}</code></pre><h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><p>增强for循环（for-each循环）是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合。它的内部原理其实是一个Iterator迭代器，所以在遍历的过程中，<br>不能对集合中的元素进行增删操作。</p><pre><code>public interface Iterable&lt;T&gt;</code></pre><p>实现这个接口允许对象成为“foreach”语句的目标。</p><pre><code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code></pre><p>所有的单列集合都可以使用增强for</p><p>增强for循环：用来遍历集合和数组</p><p>格式：</p><pre><code>for(集合/数组的数据类型 变量名 ： 集合名/数组名){    sout(变量名);}</code></pre><p>增强for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断;&lt;br&gt;如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>List集合</title>
    <link href="http://yxym.run/2020/03/03/List/"/>
    <id>http://yxym.run/2020/03/03/List/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:24.044Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*    java.util.List接口 extends　Collection接口    List接口的特点：        1.有序的集合，存储元素和取出元素的顺序是一致的        2.有索引，包含了一些带索引的方法        3.允许存储重复的元素    List接口中带索引的方法（特有）：        public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上        public E get(int index)：返回集合中指定位置的元素        public E remove(int index)：移除列表中指定位置的元素，返回的是被移除的元素        public E set(int index,E element)：用指定元素替换集合中指定位置的元素，返回值的更新前的元素    注意：        操作索引时，一定要防止索引越界异常        IndexOutOfBoundException 　索引越界异常，集合会报        ArrayIndexOutOfBoundException　数组索引越界异常        StringIndexOutOfBoundException　字符串索引越界异常 */</code></pre><a id="more"></a><p>实践代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;d&quot;);    list.add(&quot;a&quot;);    System.out.println(list);    // 在指定位置添加指定元素    list.add(3,&quot;fym&quot;);    System.out.println(list);    // 移除指定位置处的元素，返回值是被移除的元素    String re = list.remove(2);    System.out.println(re);    System.out.println(list);    // 用指定元素替换集合中指定的位置的元素，并返回被替换的元素    String setE = list.set(4,&quot;A&quot;);    System.out.println(setE);    System.out.println(list);    // list集合遍历有３种方式    // 使用普通的for循环    for (int i = 0; i &lt; list.size(); i++) {        String s = list.get(i);        System.out.println(s);    }    // 使用迭代器    Iterator&lt;String&gt; it = list.iterator();    while(it.hasNext()){        String s = it.next();        System.out.println(s);    }    // 增强for循环    for (String s : list) {        System.out.println(s);    }}</code></pre><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>它是List接口的大小可变数组的实现，允许包括null在内的所有元素.它是数组结构的，而数组结构的特点就是查询快，增删慢．</p><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小．它总是至少等于列表的大小,随着向<br>ArrayList中不断添加元素，其容量也自动增长</p><p>多线程，不是同步的</p><p>从ArrayList的底层源码来看，如果它要添加一个元素，那么会先创建一个数组，这个新创建的数组的长度是原数组长度加１<br>然后把原数组的数据放到新数组中去．所以ArrayList数组特点是查询快，因为数组里元素的地址都是连续的，<br>但是增删慢，因为每添加或者删除一个元素都得在底层调用一个数组复制的方法，所以此时效率低．</p><p>所以在设计程序时，要根据需求选择是否使用ArrayList,如果查询需求多，则使用ArrayList,如果增删需求多，那么就不建议使用．</p><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>List和Deque接口的双链列表实现，java.util.LinkdeList集合存储结构是链表结构．方便元素添加，删除操作．<br>实现所有可选的list操作，并允许所有元素（包括null）。索引到列表中的操作将从列表的开头或结尾开始遍历列表，以更接近指定索引的位置为准。</p><p>多线程，不是同步的。查询慢，增删快。如果多个线程同时访问一个链表，并且至少有一个线程在结构上修改了链表，则必须在外部进行同步。（结构上修改是指任何增加或删除一个或多个元素的操作，仅仅设置一个元素的值并不是结构的修改）<br>这通常是通过在自然封装列表的某个对象上进行同步来实现的。如果不存在这样的对象，则应使用<code>Collections.synchronizedList</code>方法“包装”列表。最好在创建时完成此操作，以防止意外的不同步访问列表：</p><pre><code>List list = Collections.synchronizedList(new LinkedList(...));</code></pre><p>可以将此集合用作堆栈、队列、双端队列。</p><h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><p>底层也是一个数组结构，Vector类可以实现可增长的对象数组，与普通数组一样，它包含可以使用整数索引进行访问的组件。但是Vector的大小可以根据需要增大或者缩小，以适应创建<br>Vector后进行添加或者移除项的操作。</p><p>它是同步的。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;/*
    java.util.List接口 extends　Collection接口
    List接口的特点：
        1.有序的集合，存储元素和取出元素的顺序是一致的
        2.有索引，包含了一些带索引的方法
        3.允许存储重复的元素
    List接口中带索引的方法（特有）：
        public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上
        public E get(int index)：返回集合中指定位置的元素
        public E remove(int index)：移除列表中指定位置的元素，返回的是被移除的元素
        public E set(int index,E element)：用指定元素替换集合中指定位置的元素，返回值的更新前的元素
    注意：
        操作索引时，一定要防止索引越界异常
        IndexOutOfBoundException 　索引越界异常，集合会报
        ArrayIndexOutOfBoundException　数组索引越界异常
        StringIndexOutOfBoundException　字符串索引越界异常
 */&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Collections工具类</title>
    <link href="http://yxym.run/2020/03/02/collections/"/>
    <id>http://yxym.run/2020/03/02/collections/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T11:48:12.887Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.Collections 是集合工具类，用来对集合进行操作。</p><p><strong>常用方法：</strong></p><p>1.<code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c,T... elements)</code></p><p>作用：一次性往集合中添加多个元素</p><pre><code>ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();// 一次性往集合中添加多个元素Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);System.out.println(list); // [a, b, c, d, e]</code></pre><p>2.<code>public static void shuffle(List&lt;?&gt; list)</code></p><a id="more"></a><p>作用：打乱集合顺序</p><pre><code>Collections.shuffle(list);System.out.println(list);</code></pre><p>注意：shuffle只能用于list，不能用于set</p><p>3.<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code></p><p>作用：将集合中元素按照<strong>默认规则</strong>排序</p><p>注意：</p><ul><li><p>sort(List<T> list)使用前提：</p><pre><code>被排序的集合里边存储的元素对象，必须实现Comparable，重写接口中的方法compareTo</code></pre></li><li><p>Comparable接口的排序规则：</p><pre><code>自己(this) - 参数 ：升序参数 - 自己 ：降序</code></pre></li></ul><p>实例代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();    list01.add(1);    list01.add(3);    list01.add(2);    System.out.println(list01);    //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序    Collections.sort(list01); // 默认是升序    System.out.println(list01);    ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;();    list02.add(&quot;a&quot;);    list02.add(&quot;c&quot;);    list02.add(&quot;b&quot;);    System.out.println(list02); // [a, c, b]    Collections.sort(list02);    System.out.println(list02); // [a, b, c]    ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;();    list03.add(new Person(&quot;张三&quot;,18));    list03.add(new Person(&quot;李四&quot;,20));    list03.add(new Person(&quot;王五&quot;,15));    System.out.println(list03); //[Person{name=&apos;张三&apos;, age=18}, Person{name=&apos;李四&apos;, age=20}, Person{name=&apos;王五&apos;, age=15}]    // 如果想使用sort方法对存储自定义类型数据的集合进行排序，那么这个自定义类型的类必须实现Comparable接口的compareTo方法    Collections.sort(list03);    System.out.println(list03);    //[Person{name=&apos;李四&apos;, age=20}, Person{name=&apos;张三&apos;, age=18}, Person{name=&apos;王五&apos;, age=15}]}</code></pre><p>其中对于自定义类型Person，存储它的集合要想使用sort方法必须实现Comparable接口的compareTo方法：</p><pre><code>public class Person implements Comparable&lt;Person&gt;{    private String name;    private int age;public Person() {}public Person(String name, int age) {    this.name = name;    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}// 重写排序的规则@Overridepublic int compareTo(Person o) {        //自定义比较的规则，比较两个人的年龄(this,参数Person)//        return this.getAge() - o.getAge(); // 升序        return o.getAge() - this.getAge(); // 降序    }}</code></pre><p><code>Comparable&lt;Person&gt;</code>表示实现这个接口，进行排序的元素的类型是Person类型。</p><p>4 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt;)</code>:</p><p>将集合中元素按照指定规则排序</p><pre><code>Comparator和Comparable的区别    Comparable:自己(this)和别人(参数)比较，自己需要实现Comparable接口，重写比较的规则    Comparator:相当于找一个第三方的裁判，比较两个元素Comparator的排序规则：    o1 - o2 : 升序    o2 - o1 : 降序</code></pre><p>实例代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();    list01.add(1);    list01.add(3);    list01.add(2);    Collections.sort(list01, new Comparator&lt;Integer&gt;() {        // 重写比较的规则        @Override        public int compare(Integer o1, Integer o2) {            //return o1 - o2;//升序            return o2 - o1; //降序        }    });    System.out.println(list01);    ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;();    list02.add(new Student(&quot;lalal&quot;,19));    list02.add(new Student(&quot;dddd&quot;,20));    list02.add(new Student(&quot;kkaka&quot;,30));    list02.add(new Student(&quot;kkaka&quot;,20));//  Collections.sort(list02, new Comparator&lt;Student&gt;() {//  @Override//  public int compare(Student o1, Student o2) {//       return o1.getAge() - o2.getAge(); // 按照年龄升序排序////     return o2.getAge() - o1.getAge(); // 按照年龄降序排序//   }//  });    Collections.sort(list02, new Comparator&lt;Student&gt;() {    @Override    public int compare(Student o1, Student o2) {          int res =  o1.getAge() - o2.getAge(); // 按照年龄升序排序           // 如果年龄相同，则按照名字首字母进行排序           if (res == 0){               res = o1.getName().charAt(0) - o2.getName().charAt(0);            }           return res;      }    });    System.out.println(list02);    // [Student{name=&apos;lalal&apos;, age=19}, Student{name=&apos;dddd&apos;, age=20}, Student{name=&apos;kkaka&apos;, age=20}, Student{name=&apos;kkaka&apos;, age=30}]    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.Collections 是集合工具类，用来对集合进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;public static &amp;lt;T&amp;gt; boolean addAll(Collection&amp;lt;T&amp;gt; c,T... elements)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;作用：一次性往集合中添加多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
// 一次性往集合中添加多个元素
Collections.addAll(list,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;);
System.out.println(list); // [a, b, c, d, e]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.&lt;code&gt;public static void shuffle(List&amp;lt;?&amp;gt; list)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap存储自定义类型键值</title>
    <link href="http://yxym.run/2020/03/02/HashMap/"/>
    <id>http://yxym.run/2020/03/02/HashMap/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:56.218Z</updated>
    
    <content type="html"><![CDATA[<p>Map集合保证key是唯一的：</p><pre><code>如果自定义类型作为key，必须重写hashCode方法和equals方法，以保证key唯一</code></pre><a id="more"></a><p>实践：</p><p>1.先定义一个自定义类Person</p><pre><code>public class Person {    private String name;    private int age;public Person() {}public Person(String name, int age) {    this.name = name;    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}@Overridepublic int hashCode() {    return Objects.hash(name, age);}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}}</code></pre><p>2.分别将String类和Person作为Map集合的key的类型</p><pre><code>public static void main(String[] args) {    show02();}/*    HashMap存储自定义类型键值    key:Person类型        Person类必须重写hashCode方法和equals方法，可以保证key唯一    value:Person类型        value可以重复(同名同年龄的人视为同一个) */private static void show02() {    HashMap&lt;Person, String&gt; map = new HashMap&lt;&gt;();    map.put(new Person(&quot;nvwang&quot;,18),&quot;yingguo&quot;);    map.put(new Person(&quot;qinshihuang&quot;,18),&quot;taiguo&quot;);    map.put(new Person(&quot;pujing&quot;,30),&quot;eluosi&quot;);    map.put(new Person(&quot;nvwang&quot;,18),&quot;maoliqiusi&quot;);    Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();    for (Map.Entry&lt;Person, String&gt; entry : set) {        Person key = entry.getKey();        String value = entry.getValue();        System.out.println(key+&quot;---&gt;&quot;+value);    }}/*    HashMap存储自定义类型键值    key：String类型        String类重写hashCode方法和equals方法，可以保证key唯一    value：Person类型        value可以重复（同名同年龄的人视为同一个） */private static void show01() {    HashMap&lt;String, Person&gt; map = new HashMap&lt;&gt;();    map.put(&quot;beijing&quot;,new Person(&quot;zhangsan&quot;,18));    map.put(&quot;shanghai&quot;,new Person(&quot;lisi&quot;,19));    map.put(&quot;guangzhou&quot;,new Person(&quot;wangwu&quot;,20));    map.put(&quot;beijing&quot;,new Person(&quot;zhaoliu&quot;,18));    Set&lt;String&gt; set = map.keySet();    for (String key : set) {        Person value = map.get(key);        System.out.println(key+&quot;---&gt;&quot;+value);    }}</code></pre><h4 id="LinkedHashMap-lt-K-V-gt"><a href="#LinkedHashMap-lt-K-V-gt" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h4><p>Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，<br>该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</p><pre><code>LinkedHashMap&lt;String, String&gt; linked = new LinkedHashMap&lt;&gt;();linked.put(&quot;a&quot;,&quot;a&quot;);linked.put(&quot;c&quot;,&quot;c&quot;);linked.put(&quot;d&quot;,&quot;d&quot;);linked.put(&quot;b&quot;,&quot;b&quot;);System.out.println(linked);//key不允许重复，有序// {a=a, c=c, d=d, b=b}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map集合保证key是唯一的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果自定义类型作为key，必须重写hashCode方法和equals方法，以保证key唯一&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://yxym.run/2020/03/02/Generics/"/>
    <id>http://yxym.run/2020/03/02/Generics/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道集合是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。<br>当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><a id="more"></a><p>泛型：是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。<br>泛型也可以看成是一个变量，用来接收数据类型。 </p><pre><code>E e:Element 元素T t:Type 类型</code></pre><p>E：未知的类型</p><p>集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型</p><p>比如ArrayList集合：</p><pre><code>public class ArrayList&lt;E&gt;{    public boolean add(E e){}    public E get(int index){}        ...}</code></pre><p>创建集合对象的时候，就会确定泛型的数据类型</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre><p>会把数据类型作为参数传递，把String赋值给E</p><pre><code>public class ArrayList&lt;String&gt;{     public boolean add(String e){}     public String get(int index){}            ...}</code></pre><h4 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h4><pre><code>public static void main(String[] args) {       show02();   }   /*       创建集合对象，使用泛型       好处：           1.避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型           2.把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）       弊端：           泛型是什么类型，只能存储什么类型的数据    */private static void show02() {   ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();   list.add(&quot;abc&quot;);   Iterator&lt;String&gt; it = list.iterator();   while(it.hasNext()){       String s = it.next();       System.out.println(s + &quot;-&gt;&quot; +s.length());   }}   /*       创建集合对象，不使用泛型       好处：           集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据       弊端：           不安全，会引发异常   */private static void show01() {   ArrayList list = new ArrayList();   list.add(&quot;abc&quot;);   list.add(1);   Iterator it = list.iterator();   while(it.hasNext()){   // 取出元素也是Object类型       Object obj = it.next();       System.out.println(obj);   // 想要使用String类特有的方法，length获取字符串长度，不能使用，       // 多态 Object obj = “abc,多态的弊端，父类引用不能调用子类特有的方法   } }</code></pre><h4 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h4><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; {}</code></pre><p>示例代码如下：</p><p>定义泛型类：</p><pre><code>/*    定义一个含有泛型的类，模拟ArrayList集合    泛型是一个未知的数据类型，当我们不确定什么数据类型的时候，可以使用泛型    泛型可以接收任意的数据类型，可以使用Integer、String....    创建对象的时候确定泛型的数据类型 */public class GenericClass&lt;E&gt; {    private E name;    public E getName() {        return name;    }    public void setName(E name) {        this.name = name;    }}</code></pre><p>使用：</p><pre><code>public class Demo02Generics {    public static void main(String[] args) {        GenericClass gc = new GenericClass();        gc.setName(&quot;只能是字符串&quot;);        Object obj = gc.getName();        System.out.println(obj);    GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;();    gc2.setName(1);    Integer name = gc2.getName();    System.out.println(name);    GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;();    gc3.setName(&quot;xiaoming&quot;);    String name1 = gc3.getName();    System.out.println(name1);}}</code></pre><h4 id="定义和使用含有泛型的方法"><a href="#定义和使用含有泛型的方法" class="headerlink" title="定义和使用含有泛型的方法"></a>定义和使用含有泛型的方法</h4><p>定义含有泛型的方法：泛型定义在方法的修饰符和返回类型之间</p><p>格式：</p><pre><code>修饰符 &lt;泛型&gt; 返回值类型 方法名（参数列表（使用泛型））{    方法体;}</code></pre><p>含有泛型的方法，在调用方法的时候确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型。</p><p>实例代码：</p><pre><code>// 想使用泛型，必须先定义再使用// 含有泛型的成员方法public &lt;M&gt; void method01(M m){    System.out.println(m);}// 含有泛型的静态方法public static &lt;M&gt; void method02(M m){    System.out.println(m);}public static void main(String[] args) {    GenericMethod gm = new GenericMethod();    /*        调用含有泛型的方法method01        传递什么类型，泛型就是什么类型     */    gm.method01(10);    gm.method01(&quot;aaa&quot;);    gm.method01(8.8);    gm.method02(&quot;静态方法，不建议创建对象使用&quot;);    // 静态方法，通过类名.方法名（参数）可以直接使用    GenericMethod.method02(&quot;静态方法&quot;);    GenericMethod.method02(1);}</code></pre><h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><p>定义格式：</p><pre><code>修饰符 interface 接口名&lt;代表泛型的变量&gt;{}</code></pre><p>含有泛型的接口的两种使用方式：</p><p>先定义含有泛型接口</p><pre><code>public interface GenericInterface&lt;I&gt; {    abstract void method(I e);}</code></pre><p>第一种使用方式：</p><pre><code>/*    含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型    例如：        public interface Iterator&lt;E&gt; {            E next();            ...        }        Scanner类实现了Interator接口，并指定接口的泛型为String，所以重写的next方法泛型默认就是String        public final class Scanner implements Iterator&lt;String&gt;{            public String next(){}        } */public class GenericInterfaceImpl01 implements GenericInterface&lt;String&gt;{    @Override    public void method(String e) {        System.out.println(e);    }}</code></pre><p>第二种使用方式：</p><pre><code>/*    含有泛型的接口的第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走    就相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型    例如：        public interface List&lt;E&gt;{            boolean add(E e);            E get(int index);        }        public class ArrayList&lt;E&gt; implements List&lt;E&gt;{            public boolean add(E e) {}            public E get(int index) {}        } */public class GenericInterfaceImpl02&lt;I&gt; implements GenericInterface&lt;I&gt;{    @Override    public void method(I e) {        System.out.println(e);    }}</code></pre><p>对以上两种方式进行调用：</p><pre><code>public static void main(String[] args) {    // 含有泛型的接口，第一种使用方法    GenericInterfaceImpl01 gi1 = new GenericInterfaceImpl01();    gi1.method(&quot;adada&quot;);    // 含有泛型的接口，第二种使用方法，创建对象的时候确定泛型的类型    GenericInterfaceImpl02&lt;Object&gt; gi2 = new GenericInterfaceImpl02&lt;&gt;();    gi2.method(8.8);    gi2.method(&quot;asasd&quot;);}</code></pre><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>当使用泛型类或者接口作为方法参数类型时，<strong>传递的数据中</strong>，<strong>泛型类型不确定</strong>，可以通过通配符&lt;？&gt;表示。但是一旦使用泛型的通配符，<br>只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><p>例如，ArrayList类型的变量作为方法参数，其中它传递的数据类型并不确定，那就需要使用通配符，如下：</p><pre><code>/*    泛型通配符：        ？：代表任意的数据类型    使用方式：        不能创建对象使用        只能作为方法的参数使用 */public static void main(String[] args) {        ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();        list01.add(1);        list01.add(2);    ArrayList&lt;Object&gt; list02 = new ArrayList&lt;&gt;();    list02.add(&quot;a&quot;);    list02.add(&quot;b&quot;);    printArray(list01);    printArray(list02);}/*    定义一个方法，能遍历所有类型的ArrayList集合    这时候不知道ArrayList集合使用什么数据类型，可以用泛型的通配符？来接收数据类型    注意：        泛型没有继承概念，即下面的ArrayList&lt;?&gt;中的问号不能用Object代替 */private static void printArray(ArrayList&lt;?&gt; list01) {    Iterator&lt;?&gt; it = list01.iterator();    while (it.hasNext()){        // it.next()方法，取出的元素是Object，可以接收任意的数据类型        Object o = it.next();        System.out.println(o);    }}</code></pre><h4 id="泛型的高级使用–受限泛型"><a href="#泛型的高级使用–受限泛型" class="headerlink" title="泛型的高级使用–受限泛型"></a>泛型的高级使用–受限泛型</h4><pre><code>/*    泛型的上限限定： ？ extends E 　代表使用的泛型只能是Ｅ类型的子类／本身    泛型的下限限定： ？　super E    代表使用的泛型只能是Ｅ类型的父类／本身 */public class Demo04 {    public static void main(String[] args) {        Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();        Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();        Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();        Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();        getElement1(list1);//        getElement1(list2); // 报错//        getElement1(list3);//        getElement1(list4);// 报错////        getElement2(list1);//　报错//        getElement2(list2);// 报错        getElement2(list3);        getElement2(list4);    }    // 泛型的上限：此时的泛型？，必须是Number类型或者Number类型的子类    public static void getElement1(Collection&lt;? extends Number&gt; coll){}    // 泛型的下限：此时的泛型？，必须是Number类型或Number类型的父类    public static void getElement2(Collection&lt;? super Number&gt; coll){}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道集合是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。&lt;br&gt;当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Collection集合</title>
    <link href="http://yxym.run/2020/03/01/CollectionClass/"/>
    <id>http://yxym.run/2020/03/01/CollectionClass/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:10.192Z</updated>
    
    <content type="html"><![CDATA[<p>集合:集合是java中提供的一种<strong>容器</strong>,可以用来存储多个数据</p><p>集合与数组的区别:</p><ul><li>数组的长度是固定的,集合的长度是可变的</li><li>数组中存储的是同一类型的元素,可以存储基本数据类型值也可以存储对象.集合存储的都是对象,而且对象的类型可以不一致.<a id="more"></a></li></ul><p><strong>学习集合的目标:</strong></p><p>1、会使用集合存储数据</p><p>2、会遍历集合，把数据取出来</p><p>3、掌握每种集合的特性</p><p><strong>集合框架的学习方式：</strong></p><p>1、学习顶层：学习顶层接口/抽象类中共性的方法，所有子类都可以使用</p><p>2、使用底层：顶层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>定义的是所有单列集合中共性的方法，所有的单列集合都可以使用共性的方法。</p><p>比如没有带索引的方法</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>实现了Collection接口，该接口定义了以下几个性质：</p><p>1、有序的集合（存储和取出元素顺序相同）</p><p>2、允许存储重复的元素</p><p>3、有索引，可以使用普通的for循环遍历。</p><p>实现了该接口的集合有Vector、ArrayList、LinkedList集合。</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>实现了Collection接口，该接口定义了以下几个性质：</p><p>1、不允许存储重复元素</p><p>2、没有索引（不能使用普通的for循环遍历）</p><p>实现了该接口的集合有TreeSet集合、HashSet集合，其中这两个集合是无序的集合（存储和取出元素的顺序有可能不一致）</p><p>LinkedHashSet集合继承了HashSet，它是一个有序的集合。</p><h4 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h4><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可用于操作所有的<br>单列集合。方法如下：</p><pre><code>public static void main(String[] args) {    // 创建集合对象，可以使用多态    Collection&lt;String&gt; coll = new HashSet&lt;&gt;();    System.out.println(coll); // 重写了toString方法 []    /*        public boolean add(E e): 把给定的对象添加到当前集合中        返回值是一个布尔值，一般都返回true，所以可以不用接收    */    boolean b1 = coll.add(&quot;张三&quot;);    System.out.println(coll);    coll.add(&quot;liss&quot;);    coll.add(&quot;liss&quot;);    coll.add(&quot;zhaoliu&quot;);    System.out.println(coll); // [张三, liss, wangwu, zhaoliu]    /*        public boolean remove(E,e):        返回值是一个boolean值，集合中存在元素，删除元素，返回true        集合中不存在元素，删除失败，返回false     */    boolean b2 = coll.remove(&quot;liss&quot;);    System.out.println(&quot;b2:&quot;+b2);    boolean b3 = coll.remove(&quot;aaa&quot;);    System.out.println(&quot;b3:&quot;+b3);    System.out.println(coll); // [张三, wangwu, zhaoliu]    /*        public boolean contains(E e):判断当前集合中是否包含给定的对象        包含返回true        不包含返回false     */    boolean b4 = coll.contains(&quot;wangwu&quot;);    System.out.println(&quot;b4:&quot;+b4); // true    boolean b5 = coll.contains(&quot;ada&quot;);    System.out.println(&quot;b5:&quot;+b5); // false    /*        public boolean isEmpty():判断当前集合是否为空     */    boolean b6 = coll.isEmpty();    System.out.println(&quot;b6:&quot;+b6); //false    /*        public int size():返回集合中元素的个数     */    int size = coll.size();    System.out.println(&quot;size:&quot;+size);    /*    public Object[] toArray():把集合中的元素，存储到数组中     */    Object[] arr = coll.toArray();    for (int i = 0;i&lt;arr.length;i++){        System.out.println(arr[i]);    }    /*        public void clear():清空集合中所有元素，但是不删除集合，集合还存在     */    coll.clear();    System.out.println(coll.isEmpty());}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合:集合是java中提供的一种&lt;strong&gt;容器&lt;/strong&gt;,可以用来存储多个数据&lt;/p&gt;
&lt;p&gt;集合与数组的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组的长度是固定的,集合的长度是可变的&lt;/li&gt;
&lt;li&gt;数组中存储的是同一类型的元素,可以存储基本数据类型值也可以存储对象.集合存储的都是对象,而且对象的类型可以不一致.
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>包装类</title>
    <link href="http://yxym.run/2020/03/01/baoZhuangClass/"/>
    <id>http://yxym.run/2020/03/01/baoZhuangClass/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-19T11:43:27.504Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据类型使用起来非常方便，但是没有对应的方法来操作这些基本数据类型的数据。<br>可以使用一个类，把基本数据类型装起来，在类中定义一些方法，这个类叫做包装类。<br>我们可以使用类中的方法来操作这些基本类型的数据。</p><p>Java中一共有8种基本数据类型，所以对应的也有8种包装类。包装类位于java.lang包，<br>可以直接使用，无需导包。</p><a id="more"></a><pre><code>byte -&gt; Byteshort -&gt; Shortint -&gt; Integerlong -&gt; Longfloat -&gt; Floatdouble -&gt; Doublechar -&gt; Characterboolean -&gt; Boolean</code></pre><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>基本数据类型与对应的包装类对象之间，来回转换的过程称为“装箱”与“拆箱”：</p><ul><li>装箱：从基本数据类型转换为对应的包装类对象</li><li>拆箱：从包装类对象转换为对应的基本类型</li></ul><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>这里以Integer类型作为例子，说明如何进行装箱操作：</p><p>主要有两大类方法实现装箱操作：</p><p>1、构造方法：</p><ul><li>Integer(int value) 构造一个新分配的Integer对象，它表示指定的int值</li><li>Integer(String s) 构造一个新分配的Integer对象，它表示String参数所指示的int值</li></ul><p>传递的字符串必须是基本数据类型的字符串v，否则会抛出异常，如”100“正确，”a“抛异常。</p><p>2、静态方法</p><ul><li>static Integer valueOf(int i) 返回一个表示指定的int值的Integer实例</li><li>static Integer valueOf(String s) 返回保存制定的String的值的Integer对象</li></ul><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>这里以Integer类型作为例子，说明如何进行拆箱操作：</p><p>成员方法：</p><pre><code>int intValue() 以int类型返回该Integer值</code></pre><p>示例代码：</p><pre><code>public static void main(String[] args) {    // 装箱    Integer in1 = new Integer(1);    System.out.println(in1); // 重写了toString方法    Integer in2 = new Integer(&quot;22&quot;);    System.out.println(in2);    // 静态方法    Integer in3 = Integer.valueOf(1);    // 拆箱    int a = in2.intValue();}</code></pre><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>基本数据类型的数据和包装类之间可以自动的相互转换,这是JDK1.5以后新加的特性.</p><pre><code>public static void main(String[] args) {    /*        自动装箱:直接把int类型的整数赋值给包装类     */    Integer in = 1;    /*        自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,再进行计算        in+2;就相当于in.intValue() + 2 = 3        in = in.intValue() + 2 = 3 又是一个自动装箱     */    in = in + 2;    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    /*    ArrayList集合无法直接存储整数,可以存储Integer包装类     */    list.add(1); // --&gt;自动装箱 list.add(new Integer(1));    int a = list.get(0); // --&gt;自动拆箱 list.get(0).intValue();}</code></pre><h3 id="基本类型与字符串类型之间的相互转换"><a href="#基本类型与字符串类型之间的相互转换" class="headerlink" title="基本类型与字符串类型之间的相互转换"></a>基本类型与字符串类型之间的相互转换</h3><ul><li><p>基本类型 -&gt; 字符串(String)</p><p>1.基本类型的值+””  最简单的方法</p><p>2.包装类的静态方法toString(参数),不是Object类的toString(),二者是重载关系</p><pre><code>static String toString(...)  返回一个表示制定参数的String对象</code></pre><p>3.String类的静态方法valueOf(参数),返回参数的字符串表示形式</p><pre><code>static String valueOf(...)</code></pre><ul><li><p>字符串(String) -&gt; 基本类型</p><p>使用包装类的静态方法parseXXX(“字符串”)</p><p>Integer类: static int parseInt(String s)</p><p>Double类: static double parseDouble(String s)</p></li></ul></li></ul><p>示例代码:</p><pre><code>public static void main(String[] args) {    int i1 = 100;    String s1 = i1+&quot;&quot;;    System.out.println(s1+200);    String s2 = Integer.toString(100);    System.out.println(s2+200);    String s3 = String.valueOf(100);    System.out.println(s3+200);    int i = Integer.parseInt(s1);    System.out.println(i-10);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本数据类型使用起来非常方便，但是没有对应的方法来操作这些基本数据类型的数据。&lt;br&gt;可以使用一个类，把基本数据类型装起来，在类中定义一些方法，这个类叫做包装类。&lt;br&gt;我们可以使用类中的方法来操作这些基本类型的数据。&lt;/p&gt;
&lt;p&gt;Java中一共有8种基本数据类型，所以对应的也有8种包装类。包装类位于java.lang包，&lt;br&gt;可以直接使用，无需导包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode算法模板二叉树的遍历</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:22.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><p>二叉树是n个结点的有限集合，其中n&gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。<br>2、二叉树中不存在度大于2的结点。<br>3、即使只有一棵子树，也要区分它是左子树还是右子树。</p><a id="more"></a><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>关于二叉树的遍历方式有很多种，主要有前、中、后、层次遍历等四种方式，在实现时也有递归的方式和非递归的方式。有很多关于二叉树的算法题目都是基于二叉树的遍历进行展开的，因此我想把二叉树的所有遍历方式进行一次全面的总结。</p><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>1、前序遍历，preVisit(root)</p><p>主要过程为以下三步：</p><ul><li>visit(toot)</li><li>preVisit(root.left)</li><li>preVisit(root.right)</li></ul><p>2、中序遍历，midVisit(root)</p><p>主要过程为以下三步：</p><ul><li>midVisit(root.left)</li><li>visit(toot)</li><li>midVisit(root.right)</li></ul><p>3、后序遍历，postVisit(root)</p><p>主要过程为以下三步：</p><ul><li>postVisit(root.left)</li><li>postVisit(root.right)</li><li>visit(toot)</li></ul><p>具体代码如下：</p><pre><code>public void preVisit(TreeNode root){   if (root==null)       return;   System.out.println(root.val);   preVisit(root.left);   preVisit(root.right);}public void midVisit(TreeNode root){   if (root==null)       return;   midVisit(root.left);   System.out.println(root.val);   midVisit(root.right);}public void postVisit(TreeNode root){   if (root==null)       return;   postVisit(root.left);   postVisit(root.right);   System.out.println(root.val);}</code></pre><h4 id="非递归，借助于栈和队列"><a href="#非递归，借助于栈和队列" class="headerlink" title="非递归，借助于栈和队列"></a>非递归，借助于栈和队列</h4><p>1、前序、中序非递归遍历<br>二者过程类似，只是访问结点的顺序有所差别，具体的代码如下：</p><pre><code>public void preVisitWithStack(TreeNode root){    if (root==null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()) {        while (node!=null){            System.out.println(node.val);            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            node = node.right;        }    }}public void midVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()){        while (node!=null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            System.out.println(node.val);            node = node.right;        }    }}</code></pre><p>都是使用两层的while循环，外层循环用于保证栈不是空的或者结点存在，然后内存循环用于一直迭代遍历结点的左子树，直到没有做子树为止，然后方向转向右子树。差别只在于访问元素位置的因为前序和中序的原因而不同。</p><p>2、后序遍历<br>后序遍历也是借助于栈，但是有一个需要注意的是还需要借助一个lastvisit指针，由于后序遍历是先左子树后右子树最后父亲结点，而程序在遍历二叉树的过程中在其左子树已经被访问过以后，什么情况下，才能访问父亲结点？一个就是该父亲结点没有右子树，所以可以直接访问父亲结点，另外一个就是该父亲结点的右子树已经被访问过了，接下来该父亲结点访问了。所以为了记录父亲结点的右子树是否被访问过，就定义了这个指针，这是很关键的一步。</p><pre><code> public void postVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    // 此处设置lastVisit指针是为了确认在某个父亲结点拥有右结点的情况下，这个右结点    // 是否已经被访问过了，如果访问了当前结点就要出栈被访问，因为后序遍历的顺序就是左右中    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                System.out.println(node.val);                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }}</code></pre><p>   3、层次遍历<br>   根据层次遍历一层一层访问的特点，可以借助队列结构来完成层次遍历。具体代码实现如下：</p><pre><code>public void levelVisit(TreeNode root){    if (root == null)        return;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.add(root);    while(!queue.isEmpty()){        root = queue.poll();        System.out.println(root.val);        if (root.left != null)            queue.add(root.left);        if (root.right != null)            queue.add(root.right);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的概念&quot;&gt;&lt;a href=&quot;#二叉树的概念&quot; class=&quot;headerlink&quot; title=&quot;二叉树的概念&quot;&gt;&lt;/a&gt;二叉树的概念&lt;/h3&gt;&lt;p&gt;二叉树是n个结点的有限集合，其中n&amp;gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。&lt;/p&gt;
&lt;h3 id=&quot;性质：&quot;&gt;&lt;a href=&quot;#性质：&quot; class=&quot;headerlink&quot; title=&quot;性质：&quot;&gt;&lt;/a&gt;性质：&lt;/h3&gt;&lt;p&gt;1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。&lt;br&gt;2、二叉树中不存在度大于2的结点。&lt;br&gt;3、即使只有一棵子树，也要区分它是左子树还是右子树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第226题</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:35.389Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>翻转二叉树</p><p>示例：</p><p>输入：</p><pre><code>       4     /   \  2     7 / \   / \1   3 6   9</code></pre><a id="more"></a><p>输出：</p><pre><code>      4    /   \  7     2 / \   / \9   6 3   1</code></pre><p>据说有个很牛逼的大佬曾经去谷歌应聘，结果倒在了这道算法题上，所以看着简单，但还是需要对数据结构这些基础知识拥有足够的重视。</p><p>这个题目看起来是让翻转二叉树，实质上是对二叉树进行遍历，只要能够遍历到结点，就能够实现对该结点的左右子树进行交换，然后要么递归从下往上做要么从上往下依次迭代实现。本文正是借用二叉树的几种遍历算法作为模板进行翻转的。</p><p><strong>解法一：递归翻转</strong></p><pre><code> // 使用递归的方式对二叉树进行翻转public TreeNode invertTree(TreeNode root) {    if (root == null)        return null;    TreeNode lchild = root.left;    TreeNode rchild = root.right;    root.left = invertTree(rchild);    root.right = invertTree(lchild);    return root;}</code></pre><p><strong>解法二：使用层次遍历进行翻转，借用了队列</strong></p><pre><code>// 使用队列对二叉树进行层次遍历的方式进行翻转二叉树public TreeNode invertTree2(TreeNode root) {    if (root == null)        return null;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    queue.add(root);    while(!queue.isEmpty()){        TreeNode cur = queue.poll();        if ((cur.left==null)&amp;&amp;(cur.right==null))            continue;        TreeNode temp = cur.left;        cur.left = cur.right;        cur.right = temp;        if (cur.left!=null)            queue.add(cur.left);        if (cur.right!=null)            queue.add(cur.right);    }    return root;}</code></pre><p><strong>解法三：使用后序遍历进行翻转，借用了栈</strong></p><pre><code> // 使用栈对二叉树进行后序遍历来翻转二叉树public TreeNode invertTree3(TreeNode root) {    if (root == null)        return null;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                TreeNode temp = node.left;                node.left = node.right;                node.right = temp;                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }    return root;}</code></pre><p>  其他的二叉树遍历方法也可以实现对二叉树的翻转，只用对二叉树便利模板程序中访问结点处的程序进行改动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻转二叉树&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       4
     /   \
  2     7
 / \   / \
1   3 6   9&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第219题</title>
    <link href="http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2020-03-09T14:47:33.131Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p><strong>示例 1:</strong></p><p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p><a id="more"></a><p><strong>示例 2:</strong></p><p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p><p><strong>分析：</strong><br>从这个题目看来，并没有要求有空间复杂度的限制，因此我们可以借助于哈希表来完成以上的操作。</p><p><strong>做法1：</strong><br>其中我的做法是借助于HashMap，以元素值作为哈希表的key值，元素的索引值作为哈希表的value值，利用for循环遍历数组，如果当前key在hashmap中没有值则存入hashmap，如果当前key在hashmap中有值则取出其value，这个value就是数组元素的索引值，然后对当前for循环的游标变量与取出来的value值进行判断，具体的代码实现如下所示：</p><pre><code> public boolean containsNearbyDuplicate(int[] nums, int k) {    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    int flag = 0;    for(int i = 0;i &lt; nums.length;i++){        if (map.get(nums[i])==null){            map.put(nums[i],i);        }else {            int j = map.get(nums[i]);            if (( j!=i)&amp;&amp;(Math.abs(i-j) &lt;= k)){                flag = 1;            }else {                map.put(nums[i],i);            }        }    }    if (flag==1)        return true;    return false;}</code></pre><p>   但是我的这个做法，无论从程序运行时间还是内存消耗，都不是很好，因此我查看了一些性能比较好的程序，在此学习记录。</p><p>**   做法2：**<br>  思路：用散列表来维护这个kk大小的滑动窗口。<br>  这个做法借助了hashset，通过设立这个集合，确保这个集合中的元素数量不大于k，一旦大于k就要删去最先存入集合的元素，其中如果在for循环结束前，要存入的元素在集合中存在了，则说明题目中所要求的那两个相等的元素找到了，如果在for循环结束以后还是没有返回true，则说明没有符合条件的元素则返回false。这个程序的作者设计的很巧妙，相比于我的程序，运行速度要快的多。<br>  具体的代码如下：</p><pre><code>public boolean containsNearbyDuplicate2(int[] nums, int k) {    if(k==35000) return false;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int i = 0; i &lt; nums.length; ++i) {        if (set.contains(nums[i])) return true;        set.add(nums[i]);        if (set.size() &gt; k) {            set.remove(nums[i - k]);        }    }    return false;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: nums = [1,0,1,1], k = 1&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第190题</title>
    <link href="http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:27:08.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</code></pre><a id="more"></a><p><strong>注意：</strong><br>我用的是Java语言，但是在Java语言中，没有无符号整型，在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响我们的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p><strong>解题思路：</strong></p><p>将一个32位的整数的二进制形式进行翻转，对于二进制形式的数，可以考虑采用位运算。并且需要注意的是有一点是对于任意的整数n，对它与1进行进行“与”运算，最终得到的结果都取决于该数字最后一位，如果是1，则说明n的二进制形式中，最后一位是1；如果是0，则说明n的二进制形式中，最后一位是0。通过这种方式，可以逐个的提取n的二进制位中的每一位数字。基于以上思路，有以下两种翻转方式：</p><ol><li>从左向右移位置，提取最后一位，从右向左移位，或运算</li></ol><p>取一个游标变量i，其取值从31到0，表示先提取n的二进制形式的最后一位，然后将倒数第二位右移到最后一位，提取；继续将倒数第三位右移到最后一位，，以此类推。代码如下：</p><pre><code>（n &gt;&gt; (31-i)）&amp; 1</code></pre><p>取完最后一位的值以后，将其进行左移，左移的位数整数前边右移时的游标变量i的值，根据对称的性质可知，翻转正是将第31位移到第0位，第30位移到第1位；代码如下：</p><pre><code>（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>再声明一个结果变量result，初始值为0，它将与每次左移后的结果进行“或”运算，经过31次或运算之后，它就是最终的翻转的结果值。</p><pre><code>result |（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>完整的代码实现如下：</p><pre><code>public int reverseBits(int n) {       int ret = 0;    for (int i =31;i&gt;=0;i--){       ret = ret | (((n&gt;&gt;(31-i))&amp;1) &lt;&lt; i);   }   return ret; }</code></pre><p>  ii. 第二种方式，是我在题解中看到的一个内存空间消耗较少的程序，因为上一个方法虽然运行时间特别快，超过了100%的人，但是内存消耗却只超过了5%的人的程序。在这个方式中，也是声明了一个结果变量ret，但是它并没有先右移，然后提取，再左移，最后或运算；而是也对res变量进行移位操作，即先将res左移，提取完原数的最后一位之后与res或运算，然后直接将就地对n右移，完整的代码如下：</p><pre><code>public int reverseBits2(int n){    int res = 0;    int count = 0;    while (count &lt; 32) {        res &lt;&lt;= 1;        res |= (n &amp; 1);        n &gt;&gt;= 1;        count ++;    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>GO语言学习之函数</title>
    <link href="http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/</id>
    <published>2020-02-26T14:41:00.000Z</published>
    <updated>2020-02-26T14:43:50.613Z</updated>
    
    <content type="html"><![CDATA[<p>在go语言中,函数存在以下几个与其他编程语言显著不同的地方:<br>1、函数可以有多个返回值<br>2、所有的参数传递都是值传递的方式<br>3、函数可以作为变量的值<br>4、函数可以作为参数和返回值</p><p>本文主要针对第四点来进行笔记记录</p><a id="more"></a><h3 id="函数可以作为参数和返回值"><a href="#函数可以作为参数和返回值" class="headerlink" title="函数可以作为参数和返回值"></a>函数可以作为参数和返回值</h3><p>首先定义一个函数timeSpent，它的作用类似于面向对象编程中的装饰者模式，对一个函数“装饰”上记录运行时间的功能，以此来衡量一个函数的运行时间，其中被衡量的函数是作为参数传入到timeSpent中去的，代码如下：</p><pre><code>func timeSpent(inner func(op int) int) func (opt int) int{return func(n int) int {    start := time.Now()    ret := inner(n)    fmt.Println(&quot;time spent&quot;,time.Since(start).Seconds())    return ret}}</code></pre><p>其中，传入的参数是一个函数类型，该参数函数的返回值是一个整型，timeSpent的返回值类型也为一个函数类型。</p><p>然后定义一个用来测试的函数：</p><pre><code>func slowFun(op int) int{    time.Sleep(time.Second*1)    return  op}</code></pre><p>该函数并没有多余的功能，只是将传入的参数再次原值返回，期间函数会休眠一段时间。</p><p>调用执行：</p><pre><code>func TestFn(t *testing.T)  {tsSF := timeSpent(slowFun)t.Log(tsSF(10))}</code></pre><p>程序的执行过程如下：<br>1、首先将slowFun函数作为参数传入到timeSpent中去，然后将其装饰为一个具有记录运行时间的函数后，返回一个被装饰的函数，return后方的函数内部逻辑并不执行，只是将原有的函数进行装饰；<br>2、tsSF被赋予一个函数，该函数的具体业务逻辑等同于timeSpent函数中return语句后方的函数；<br>3、调用执行tsSF，传入参数10，执行逻辑见timeSpent中return语句后方的部分，打印输出10。</p><p>以上就是go语言中函数作为参数和返回值的实例，此种编程模式也成为函数式编程，可以在《计算机程序的构造与解释》这本书中了解更多更深入的关于函数式编程的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在go语言中,函数存在以下几个与其他编程语言显著不同的地方:&lt;br&gt;1、函数可以有多个返回值&lt;br&gt;2、所有的参数传递都是值传递的方式&lt;br&gt;3、函数可以作为变量的值&lt;br&gt;4、函数可以作为参数和返回值&lt;/p&gt;
&lt;p&gt;本文主要针对第四点来进行笔记记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go语言学习笔记" scheme="http://yxym.run/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>大学回忆一</title>
    <link href="http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2020-02-26T15:18:24.181Z</updated>
    
    <content type="html"><![CDATA[<p>时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。<a id="more"></a>回望本科四年，心中却没有泛起丝毫波澜，或许是因为大学生活过的平凡无奇，或许是因为年过20早已没有了十几岁的热情与心气。</p><p>本科四年，是我特别想要证明自己的四年，或许是因为对高考结果的不满，或许是因为对自己的不甘心，总之在踏入校园的那一刻起，我发誓我一定要做一个追逐优秀的人，我没有对任何说，因为我也不认识任何人，哈哈哈。可就是这股力量一直在驱动着我前进，我努力地学习每一门课程，以使自己对所学的课程都能有一个深刻的认识与理解而不是简单地只为拿一个不错的期末分数，诚然，我这么学，每一门分数也都是很理想的，当然，英语除外，其实我当年英语也他挺好的，只是后来碰到了一位经常把我讲睡着的英语老师，然后就对英语彻底丧失了兴趣，以至于英语成绩一直不愠不火，哈哈哈。</p><p>我大学是软件工程，其实我在上大学之前对计算机的认识只有能打游戏和能做PPT这两种认识，更别说那些什么CPU、GPU、内存等什么专业术语，一开学的时候我挺自卑的，因为别人能一起侃侃而谈，我却对此一窍不通，这种感觉严重的刺痛了我，妈的，老子不能服输，因此我一边学习理论知识，一边了解计算机相关的知识，不管是硬件还是软件，只要是和Computer相关，我都会刻意去了解，慢慢滴也对这些知识熟悉了起来。另一个自卑的就是自己的编程能力了，有的同学大一的时候就能参加竞赛拿奖而我还只是一个臭弟弟，没办法，我这个人就是比较的自找没趣，喜欢和比我强的人比，也许是我争强好胜的原因，其实这一点挺不好的，因为容易把自己的心态搞砸了，心态一旦失衡，做什么事都容易翻车。扯远了，继续刚才的话题，为让自己也能编程能力有个大的提高，自己也在寒暑假学习编程语言，练习编程。虽然不能说自己能力提高了很多，但是起码上手的速度快了很多。现在回忆那些生活，突然有些小怀念了，哈哈哈，总之那段生活挺单调的，因为自己没交多少朋友，甚至能连学校有多少好吃的都不知道哈哈哈，因为每天标准的吃米饭套餐，哎，人生苦短，要及时行乐啊，不能苦了自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。
    
    </summary>
    
    
      <category term="活有所思" scheme="http://yxym.run/categories/%E6%B4%BB%E6%9C%89%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
</feed>
