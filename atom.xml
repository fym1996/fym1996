<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有心有梦</title>
  
  <subtitle>YXYM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxym.run/"/>
  <updated>2020-04-06T07:29:23.981Z</updated>
  <id>http://yxym.run/</id>
  
  <author>
    <name>疯渔民</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式接口</title>
    <link href="http://yxym.run/2020/04/06/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yxym.run/2020/04/06/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-06T07:29:23.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>####　基本概念</p><p>​    函数式接口在Java语言中指的是<strong>有且仅有一个抽象方法</strong>的接口，但是这个接口也可以同时拥有多个非抽象方法。这种接口主要用于函数式编程的场景，而在Java语言中，函数式编程就体现在Lambda表达式，所以如果一个接口是函数式接口，那么就可以对其使用Lambda表达式进行隐式转换，同时Lambda表达式代表的就是接口中的那个唯一的抽象方法。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>函数式接口只有一个抽象方法；</li><li>default修饰的方法不属于抽象方法；</li><li>该接口中重写的Object类的公共方法（比如<em>equals、toString、hashCode</em>）也不计入接口的抽象方法数量中。</li><li>@FunctionalInterface注解用于声明被修饰的接口是一个函数式接口，一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。但是没有该注解，只有一个抽象方法，也依然是函数式接口。</li><li>函数式接口的实例创建方式有三种，即labmbda表达式、方法引用、构造函数引用</li></ul><h4 id="JDK自带的函数式接口"><a href="#JDK自带的函数式接口" class="headerlink" title="JDK自带的函数式接口"></a>JDK自带的函数式接口</h4><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.util.Comparator</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener</li><li>javax.swing.event.ChangeListener</li><li>java.util.function</li></ul><h4 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不标明函数式接口的注解，只有只拥有一个抽象方法，也是函数式接口</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值 方法名称(参数列表)</span><br><span class="line">    <span class="comment">// 其他方式 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// public abstract 可以不写 编译器自动加上</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">       返回值 方法名称(参数列表)</span><br><span class="line">    <span class="comment">// 其他方式 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 标明为函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> MyFunctionInterface&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mrthod</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数式接口的创建与引用"><a href="#函数式接口的创建与引用" class="headerlink" title="函数式接口的创建与引用"></a>函数式接口的创建与引用</h4><p>1.使用lambda表达式创建函数式接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用自定义函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doSomething(()-&gt; System.out.println(<span class="string">"我的自定义函数式接口的实例是通过lambda实现的"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(myOwnFunctionInterface functionInterface)</span></span>&#123;</span><br><span class="line">        functionInterface.ownMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个自定义的函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">myOwnFunctionInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ownMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用lambda表达式对Java常用的函数式接口进行一个代码测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        integers.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    forEach方法被声明在Iterable接口中，被关键字default修饰，所以该实现该接口的所有的类都会继承这个forEach方法的实现，List接口间接实现了Iterable接口，所以也继承了这个default方法，forEach方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Consumer是Java中的一个常用的函数式接口，其内部只有一个抽象方法，就是accept方法，该方法接收一个参数，并且没有返回值，所以我们就使用lambda表达式创建函数式接口的实例。</p><p>​    <strong>如果使用lambda表达式来创建一个函数式接口实例，那这个lambda表达式的入参和返回必须符合这个函数式接口中唯一的抽象方法的定义。</strong></p><p>3.使用<strong>方法引用</strong>创建函数式接口的实例</p><p>方法引用的语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object :: Method</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    integers.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用<strong>构造方法的引用</strong>创建函数式接口的实例</p><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 :: new</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    integers.forEach(Test02::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test02</span><span class="params">(Integer item)</span></span>&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda表达式作为函数式接口类型的返回值"><a href="#Lambda表达式作为函数式接口类型的返回值" class="headerlink" title="Lambda表达式作为函数式接口类型的返回值"></a>Lambda表达式作为函数式接口类型的返回值</h4><p>​    如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式(类始于new 内部类的实现方式 方法中可以实现构造内部类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newComparator_1方法的返回值类型是Comparator&lt;String&gt;（函数式接口）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//  按照字符串长度进行降序排序</span></span><br><span class="line">    <span class="keyword">return</span> (a,b)-&gt;b.length()- a.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] strings = &#123;<span class="string">"Hellooooo"</span>,<span class="string">" World"</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line"></span><br><span class="line">    Arrays.sort(strings,newComparator_1());</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line"></span><br><span class="line">    Arrays.sort(strings,(a,b)-&gt;(b.length() - a.length()));</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line"></span><br><span class="line">    Arrays.sort(strings,newComparator_2());</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数式接口&quot;&gt;&lt;a href=&quot;#函数式接口&quot; class=&quot;headerlink&quot; title=&quot;函数式接口&quot;&gt;&lt;/a&gt;函数式接口&lt;/h3&gt;&lt;p&gt;####　基本概念&lt;/p&gt;
&lt;p&gt;​    函数式接口在Java语言中指的是&lt;strong&gt;有且仅有一个抽象方法&lt;/
      
    
    </summary>
    
    
      <category term="Java Se" scheme="http://yxym.run/categories/Java-Se/"/>
    
    
  </entry>
  
  <entry>
    <title>Java内存分析</title>
    <link href="http://yxym.run/2020/03/30/Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    <id>http://yxym.run/2020/03/30/Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:28:17.417Z</updated>
    
    <content type="html"><![CDATA[<p>Java内存主要分为三个部分：</p><ul><li>堆<ul><li>存放new的对象和数组</li><li>可以被所有的线程共享，不会存放别的对象引用</li></ul></li><li>栈<ul><li>存放基本变量类型（会包含这个基本类型的具体数值）</li><li>引用对象的变量（会存放这个引用在在堆里面的具体地址）</li></ul></li><li>方法区<ul><li>可以被所有的线程共享</li><li>包含了所有的class和static变量</li></ul></li></ul><a id="more"></a><h4 id="类加载到内存的流程"><a href="#类加载到内存的流程" class="headerlink" title="类加载到内存的流程"></a>类加载到内存的流程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化：</p><ol><li><strong>加载</strong>(<em>Load</em>)：这是由类加载器（<em>ClassLoader</em>）执行的。通过一个类的全限定名来获取其定义的二进制字节流（<em>class</em>文件字节码），<strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</strong>，根据字节码在<strong>Java堆</strong>中生成一个代表这个类的<code>java.lang.Class</code>对象。</li><li><strong>链接</strong>(<em>Link</em>)：将Java类的二进制代码合并到JVM的运行状态之中，包括三步：<ul><li>验证：确保加载的类信息（class文件中的字节流包含的信息）符合JVM规范，没有安全方面的问题；</li><li>准备：正式为类变量(static)分配内存并<strong>设置类变量默认初始值的阶段</strong>，这些内存都将在方法区中进行分配；</li><li>解析：虚拟机常量池内的<strong>符号引用</strong>(常量名)替换为<strong>直接引用</strong>(地址)的过程。</li></ul></li><li><strong>初始化</strong>(<em>Initalize</em>)：到了此阶段，才真正开始执行类中定义的<em>Java</em>程序代码。<ul><li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）；</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化；</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步；</li></ul></li></ol><p>用代码来分析一下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.加载到内存，会产生一个类对应的Class对象</span></span><br><span class="line"><span class="comment">        2.链接，链接结束后 m = 0</span></span><br><span class="line"><span class="comment">        3.初始化</span></span><br><span class="line"><span class="comment">            &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">                System.out.println("AA类静态代码块");</span></span><br><span class="line"><span class="comment">                m = 300;</span></span><br><span class="line"><span class="comment">                m = 100;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            m = 100;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(AA.m);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            输出结果：</span></span><br><span class="line"><span class="comment">                AA类静态代码块</span></span><br><span class="line"><span class="comment">                100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        AA aa = <span class="keyword">new</span> AA();</span><br><span class="line">        System.out.println(aa.m);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            输出结果：</span></span><br><span class="line"><span class="comment">                AA类静态代码块</span></span><br><span class="line"><span class="comment">                AA类无参构造函数初始化</span></span><br><span class="line"><span class="comment">                100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"AA类静态代码块"</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AA类无参构造函数初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>所有的类都是在对其第一次使用时，动态加载到JVM中的（懒加载）。</strong>当程序创建第一个对类的<strong>静态成员</strong>的引用时，就会加载这个类。使用<strong>new创建类对象</strong>的时候也会被当作对类的静态成员的引用。<strong>因此Java程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的。</strong>这一点与许多传统语言都不同。动态加载使能的行为，在诸如C++这样的静态加载语言中是很难或者根本不可能复制的。</p><p>​    在进行类加载的时候，类加载器会先检查这个类的Class对象是否已经加载，如果还未加载，则默认的类加载器就会<strong>根据类名查找.class文件</strong>(这里不一定都是从文件系统中获取，可以从数据库读取字节码或者接受网络中传输过来的字节码)。这些字节码在被加载的时候，会检查验证保证它们没有被破坏。<strong>一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。</strong></p><p>​    通过上面的过程我们还可以直到，static变量在链接阶段就已经有默认值了，所以在类没有的被初始化的时候，就可以调用static变量了。</p><p>这里要解释一下三个概念，字面量、符号引用、直接引用：</p><ul><li>字面量：用于表达源代码中一个固定值的表示法，比如Java中的常数1,2，..等，或者说字符串”abcd”  “java”等</li><li>符号引用：以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可。例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如<em>org.simple.People</em>类引用了<em>org.simple.Language</em>类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号<em>org.simple.Language</em>来表示<em>Language</em>类的地址。</li><li>直接引用可以是以下三种：<ul><li>直接指向目标的指针.( 指向方法区中类对象, 类变量和类方法的指针)；</li><li>相对偏移量，通过偏移量虚拟机可以直接在该类的内存区域中找到实例方法字节码或者实例变量字节码的起始位置；</li><li>一个间接定位到对象的句柄；</li></ul></li></ul><p>​    符号引用通常是设计字符串的——<strong>用文本形式来表示引用关系</strong>。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><p>​    通过上面的Object类的getClass方法我们可以取得该类已经被实例化了的（new 运算的）对象的类的引用，这个引用指向的是Class类的对象。比如，我们看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建User对象，并调用getClass方法获取类的引用</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">System.out.println(user.getClass());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：class 反射.User</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">// 通过反射获取类User的Class对象</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"反射.User"</span>);</span><br><span class="line">System.out.println(c1); </span><br><span class="line"><span class="comment">// 输出结果：class 反射.User</span></span><br></pre></td></tr></table></figure><p>getClass方法返回的就是<strong>当前对象的运行时类</strong>，就是实际创建当前对象的那个类的引用。</p><h4 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h4><h5 id="什么时候会发生类初始化"><a href="#什么时候会发生类初始化" class="headerlink" title="什么时候会发生类初始化"></a>什么时候会发生类初始化</h5><ul><li>类的主动引用（一定会发生类的初始化）<ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用的类的静态成员（除了final常量）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li></ul></li><li>类的被动引用（不会发生类的初始化）<ul><li>当访问一个静态域的时候，<strong>只有真正声明这个域的类才会被初始化</strong>。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li><li>通过数组定义<strong>类引用</strong>，不会触发此类的初始化；</li><li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li></ul></li></ul><p>用代码展示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"加载Main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.主动引用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            加载Main</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.反射也会产生主动引用</span></span><br><span class="line">        <span class="comment">//Class.forName("反射.Son");</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            加载Main</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            子类被加载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.调用的类的静态成员（除了final常量）和静态方法会初始化类</span></span><br><span class="line">        <span class="comment">// 但是，当访问一个静态域的时候，只有真正声明这个域的类才会被初始化</span></span><br><span class="line">        <span class="comment">// 所以下面这个语句的输出结果为：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            加载Main</span></span><br><span class="line"><span class="comment">            父类被加载</span></span><br><span class="line"><span class="comment">            100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// System.out.println(Son.a);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过数组定义类引用，不会导致类的初始化</span></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            加载Main</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 引用常量也不会导致类的初始化</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.c);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            加载Main</span></span><br><span class="line"><span class="comment">            100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li><li>类缓存：标准的Java SE加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li></ul><p>JVM规范定义了如下类型的类加载器：</p><ul><li>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库（rt.jar包），用来装载核心类库。该加载类无法直接获取。</li><li>扩展类加载器：负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库；</li><li>系统类加载器：负责java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。</li></ul><p>实际用代码来调用一下加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取系统类的加载器</span></span><br><span class="line">    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取系统类加载器的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">    ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">    System.out.println(parent);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sun.misc.Launcher$ExtClassLoader@677327b6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）</span></span><br><span class="line">    ClassLoader parent1 = parent.getParent();</span><br><span class="line">    System.out.println(parent1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试当前类是哪个加载器加载的</span></span><br><span class="line">    ClassLoader classLoader = Class.forName(<span class="string">"反射.Test07"</span>).getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试JDK内置的类是谁加载的</span></span><br><span class="line">    classLoader = Class.forName(<span class="string">"java.lang.Object"</span>).getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何获得系统类加载器可以加载的路径</span></span><br><span class="line">    System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/charsets.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/deploy.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/cldrdata.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/dnsns.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/jaccess.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/jfxrt.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/localedata.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/nashorn.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/sunec.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/sunjce_provider.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/sunpkcs11.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/ext/zipfs.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/javaws.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/jce.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/jfr.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/jfxswt.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/jsse.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/management-agent.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/plugin.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/resources.jar:</span></span><br><span class="line"><span class="comment">    /usr/java/jdk1.8.0_231/jre/lib/rt.jar:</span></span><br><span class="line"><span class="comment">    /home/fym/文档/JavaProject/production/learn_java:</span></span><br><span class="line"><span class="comment">    /home/fym/文档/JavaProject/learn_java/src/lib/commons-io-2.6.jar:</span></span><br><span class="line"><span class="comment">    /usr/local/idea-IU-193.5233.102/lib/idea_rt.jar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        双亲委派机制：</span></span><br><span class="line"><span class="comment">            当我们自己定义一个类的时候，JVM会自己一层一层从用户类加载器到扩展类加载器</span></span><br><span class="line"><span class="comment">            再到引导类加载器的找有没有同名的包，如果有的话则不会调用我们自己写的类，</span></span><br><span class="line"><span class="comment">            而是去用JVM自己的。这是为了保证安全。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出系统类加载器加载的也有我们项目路径和IDE的Jar包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java内存主要分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆&lt;ul&gt;
&lt;li&gt;存放new的对象和数组&lt;/li&gt;
&lt;li&gt;可以被所有的线程共享，不会存放别的对象引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈&lt;ul&gt;
&lt;li&gt;存放基本变量类型（会包含这个基本类型的具体数值）&lt;/li&gt;
&lt;li&gt;引用对象的变量（会存放这个引用在在堆里面的具体地址）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法区&lt;ul&gt;
&lt;li&gt;可以被所有的线程共享&lt;/li&gt;
&lt;li&gt;包含了所有的class和static变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="http://yxym.run/2020/03/30/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yxym.run/2020/03/30/%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:28:04.556Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>Annotation是从JDK5.0开始引入的新技术</p></li><li><p>Annotation的作用：</p><ul><li>不是程序本身，可以对程序作出解释。（这一点和注释(comments)没什么区别）</li><li>可以被其他程序（比如：编译器）读取。</li></ul></li><li><p>Annotation的格式：</p><ul><li>注解是以”@注释名”在代码中存在的，还可以添加一些参数值。例如：@SuppressWarnings(value=”unchecked”)</li></ul></li><li><p>Annotation在哪里使用？</p><ul><li>可以附加在package、class、method、field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。</li></ul></li></ul><a id="more"></a><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><ul><li><p>@Override：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</p></li><li><p>@Deprecated：定义在java.lang.DEprecated中，此注释可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</p></li><li><p>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。</p><ul><li><p>与前两个注解有所不同的是，你需要添加一个参数才能正常使用，这些参数都是已经定义好的，我们选择性使用就好了。</p><p><code>@SuppressWarnings(&quot;all&quot;)、@SuppressWarnings(&quot;unchecked&quot;)、@SuppressWarnings(value={&quot;unchecked&quot;,&quot;deprecation&quot;})</code>等等</p></li></ul></li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明；</li><li>这些类型和它们所支持的类在java.lang.annotation包中可以找到；<ul><li>@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）；</li><li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期；<ul><li>(SOURCE &lt; CLASS &lt; RUNTIME，分别表示源代码时期、编译后、运行时)；</li></ul></li><li>@Document：说明该注解将被包含在javadoc中；</li><li>@Inherited：说明子类可以继承父类中的该注解；</li></ul></li></ul><p><strong>@Target</strong>元注解的源代码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到，定义一个注解的方式正是“访问权限修饰符+@interface+注解名字”，value()在这里并不是一个方法，而是一个参数名字，而这个参数类型为ElementType[]，即一个数组类型，这个类型的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElementType本身是一个枚举类型，其中包含的是多个注解的作用域，从类型到字段、方法等等。我们在此处使用一个Target这个元注解，定义一个自己的注解，然后用Target注解它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个注解</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处Target表示我们的注解可以用在什么地方，现在我们传入的参数是METHOD、TYPE，表示我们的注解可以放在方法或者类上边。</p><p><strong>@Retention</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出Retention注解作用域就是注解的注解，同时这个注解在运行时有效（源代码和编译期都有效）, RetentionPolicy也是一个枚举类型，包含了三个作用域字段，其中RUNTIME&gt;CLASS&gt;SOURCE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul><li>使用@interface自定义注解，自动继承了java.lang.annotation.Annotation接口</li></ul><p>分析：</p><ul><li>@interface用来声明一个注解，格式：public @ interface 注解名 {定义内容}</li><li>其中的每一个方法实际上是声明了一个配置参数；</li><li>方法的名称就是参数的名称；</li><li>返回值类型就是参数的类型（返回值只能是基本类型，Class、String、enum）；</li><li>可以通过default来声明参数的默认值；</li><li>如果只有一个参数成员，一般参数名为value；</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解可以显示赋值，如果没有默认值，我们就必须给注解赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>2(name = <span class="string">"lalal"</span>,schools = &#123;<span class="string">""</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>3(<span class="string">""</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">// 注解的参数：参数类型+参数名()</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>; <span class="comment">// 如果默认值为-1，代表不存在</span></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果注解只有一个参数，那么一般将这个参数命名为value()，</span></span><br><span class="line"><span class="comment">    那么我们在使用注解的时候，可以省略value这个参数名称，直接写入实参</span></span><br><span class="line"><span class="comment">    只能是value的时候才能这样做</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation3&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Annotation是从JDK5.0开始引入的新技术&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Annotation的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是程序本身，可以对程序作出解释。（这一点和注释(comments)没什么区别）&lt;/li&gt;
&lt;li&gt;可以被其他程序（比如：编译器）读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Annotation的格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注解是以”@注释名”在代码中存在的，还可以添加一些参数值。例如：@SuppressWarnings(value=”unchecked”)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Annotation在哪里使用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以附加在package、class、method、field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>反射操作注解</title>
    <link href="http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:27:49.616Z</updated>
    
    <content type="html"><![CDATA[<p>ORM，Object Relationship Mapping –&gt;对象关系映射</p><ul><li>类和表结构对象</li><li>属性和字段对应</li><li>对象和记录对应</li></ul><a id="more"></a><p>练习ORM，要求利用注解和反射完成类和表结构的映射关系。</p><p>首先定义两个注解，一个用来注解类名，一个用来注解属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// 类名的注解</span></span><br><span class="line"><span class="meta">@interface</span> Tablelala&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@interface</span> FieldKuang&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>; <span class="comment">//列名的注解</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>; <span class="comment">// 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>; <span class="comment">// 长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个实体类Student，分别为类名和属性作上之前我们定义的两个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tablelala</span>(<span class="string">"db_student"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieldKuang</span>(columnName = <span class="string">"db_id"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@FieldKuang</span>(columnName = <span class="string">"db_age"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@FieldKuang</span>(columnName = <span class="string">"db_name"</span>,type = <span class="string">"varchar"</span>,length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student2</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student2&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射分别获取类的注解和属性的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">    Class aClass = Class.forName(<span class="string">"反射.Student2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射获得注解，此时得到的是类名的注解</span></span><br><span class="line">    Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">    <span class="comment">//  打印输出得到的Student类的类名注解</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        System.out.println(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果：@反射.Tablelala(value=db_student)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得注解的value的值</span></span><br><span class="line">    <span class="comment">// 获得指定注解</span></span><br><span class="line">    Tablelala tablelala = (Tablelala)aClass.getAnnotation(Tablelala<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String value = tablelala.value();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    <span class="comment">// 输出结果：db_student</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得类中属性的注解</span></span><br><span class="line">    Field f = aClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    <span class="comment">// 获取name字段的注解</span></span><br><span class="line">    FieldKuang annotation = f.getAnnotation(FieldKuang<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(annotation.columnName()); <span class="comment">// db_name</span></span><br><span class="line">    System.out.println(annotation.type());  <span class="comment">// varchar</span></span><br><span class="line">    System.out.println(annotation.length()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORM，Object Relationship Mapping –&amp;gt;对象关系映射&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类和表结构对象&lt;/li&gt;
&lt;li&gt;属性和字段对应&lt;/li&gt;
&lt;li&gt;对象和记录对应&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>反射操作泛型</title>
    <link href="http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:27:43.508Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除；</li><li>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。<ul><li>ParameterizedType：表示一种参数化类型，比如Collection<String>;</li><li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型；</li><li>TypeVariable：是各种类型变量的公共父接口;</li><li>WildcardType：代表一种通配符类型表达式;</li></ul></li></ul><a id="more"></a><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test01"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test02"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Method method = Test11.class.getMethod("test", Map.class, List.class);</span><br><span class="line">    <span class="comment">// 获得该Method对象的泛型参数类型</span></span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">        System.out.println(<span class="string">"#"</span>+genericParameterType);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            即test方法的参数有两个，而且都是泛型参数，他们的类型是：</span></span><br><span class="line"><span class="comment">                java.util.Map&lt;java.lang.String, 反射.User&gt;</span></span><br><span class="line"><span class="comment">                java.util.List&lt;反射.User&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前的泛型参数类型是否是参数化类型,如果是参数化类型，则将它强制转换成参数化类型</span></span><br><span class="line">        <span class="comment">// 然后调用getActualTypeArguments方法，获取参数化类型中的真实参数信息</span></span><br><span class="line">        <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            <span class="comment">// 获得真实参数信息</span></span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method = Test11.class.getMethod("test02",null);</span><br><span class="line">    Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">        <span class="comment">// 获得真实参数信息</span></span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">            System.out.println(actualTypeArgument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        class java.lang.String</span></span><br><span class="line"><span class="comment">        class 反射.User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除；&lt;/li&gt;
&lt;li&gt;为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。&lt;ul&gt;
&lt;li&gt;ParameterizedType：表示一种参数化类型，比如Collection&lt;String&gt;;&lt;/li&gt;
&lt;li&gt;GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型；&lt;/li&gt;
&lt;li&gt;TypeVariable：是各种类型变量的公共父接口;&lt;/li&gt;
&lt;li&gt;WildcardType：代表一种通配符类型表达式;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>创建运行时类的对象</title>
    <link href="http://yxym.run/2020/03/30/%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yxym.run/2020/03/30/%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:28:51.813Z</updated>
    
    <content type="html"><![CDATA[<h4 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h4><p>通过反射获取运行时类的完整结构，Field、Method、Constructor、Superclass、Interface、Annotation，获取的操作都在java.lang.reflect包下。</p><ul><li>实现的全部接口</li><li>所继承的父类</li><li>全部的构造器</li><li>全部的方法</li><li>全部的Field</li><li>注解</li></ul><a id="more"></a><p>先定义一个自定义的User类，然后获取这个类的全部信息：</p><p>User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id="</span> + id +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码获取User类的全部信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"反射.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">// 获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获得类名</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            反射.User</span></span><br><span class="line"><span class="comment">            User</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的属性</span></span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        Field[] fields;</span><br><span class="line">        fields = c1.getFields(); <span class="comment">// 只能找到public属性</span></span><br><span class="line">        fields = c1.getDeclaredFields(); <span class="comment">// 可以找到全部属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            private java.lang.String 反射.User.name</span></span><br><span class="line"><span class="comment">            private int 反射.User.id</span></span><br><span class="line"><span class="comment">            private int 反射.User.age</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获得指定属性的值</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            private java.lang.String 反射.User.name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        <span class="comment">// 获得本类及其父类的全部public方法</span></span><br><span class="line">        Method[] methods = c1.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正常的："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            正常的：public void 反射.User.setId(int)</span></span><br><span class="line"><span class="comment">            正常的：public int 反射.User.getAge()</span></span><br><span class="line"><span class="comment">            正常的：public void 反射.User.setAge(int)</span></span><br><span class="line"><span class="comment">            正常的：public java.lang.String 反射.User.toString()</span></span><br><span class="line"><span class="comment">            正常的：public java.lang.String 反射.User.getName()</span></span><br><span class="line"><span class="comment">            正常的：public void 反射.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">            正常的：public int 反射.User.getId()</span></span><br><span class="line"><span class="comment">            正常的：public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">            正常的：public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">            正常的：public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">            正常的：public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">            正常的：public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">            正常的：public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">            正常的：public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">            正常的：public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获得本类的所有方法，包括私有的方法</span></span><br><span class="line">        methods = c1.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">"getDeclaredMethods:"</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public void 反射.User.setId(int)</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public int 反射.User.getAge()</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public void 反射.User.setAge(int)</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public java.lang.String 反射.User.toString()</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public java.lang.String 反射.User.getName()</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public void 反射.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">            getDeclaredMethods:public int 反射.User.getId()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定的方法</span></span><br><span class="line">        Method getName = c1.getMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Method setName = c1.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(getName);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public java.lang.String 反射.User.getName()</span></span><br><span class="line"><span class="comment">            public void 反射.User.setName(java.lang.String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得指定的构造器</span></span><br><span class="line">        System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">        Constructor[] constructor = c1.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor1 : constructor) &#123;</span><br><span class="line">            System.out.println(constructor1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public 反射.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment">            public 反射.User()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        constructor = c1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor1 : constructor) &#123;</span><br><span class="line">            System.out.println(constructor1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public 反射.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment">            public 反射.User()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得指定的构造器</span></span><br><span class="line">        Constructor declaredConstructor = c1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"指定的："</span>+declaredConstructor);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            指定的：public 反射.User(java.lang.String,int,int)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h4><p>有了Class对象，能做什么？</p><ul><li>创建类的对象：调用Class对象的newlnstance()方法<ul><li>1）类必须有一个无参数的构造器</li><li>2）类的构造器的访问权限需要足够</li></ul></li></ul><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取User类对应的Class对象</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"反射.User"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用反射构造一个User对象</span></span><br><span class="line">User user = (User)c1.newInstance(); <span class="comment">// 本质是调用了类的无参构造器</span></span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    User&#123;name='null', id=0, age=0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果将User中的无参构造器删掉，那么就会抛出异常</span></span><br></pre></td></tr></table></figure><p><strong>思考：</strong>难道没有无参的构造器就不能创建对象了么？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</p><p>步骤如下：</p><p>1）通过Class对象的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器；</p><p>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；</p><p>3）通过Constructor实例化对象；</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造器创建一个对象，此时即使User类中没有无参构造器，我们也可以创建User对象</span></span><br><span class="line">Constructor declaredConstructor = c1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">User user = (User)declaredConstructor.newInstance(<span class="string">""</span>, <span class="number">001</span>, <span class="number">18</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        User&#123;name='', id=1, age=18&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>通过反射调用普通的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先通过反射获取一个方法</span></span><br><span class="line">Method setName = c1.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// invoke : 激活的意思，参数（对象，"方法的值"）</span></span><br><span class="line">setName.invoke(user,<span class="string">"lalala"</span>);</span><br><span class="line">System.out.println(user.getName());</span><br></pre></td></tr></table></figure><p>总结一下，通过反射得到的对象调用指定的方法的过程，通过Method完成：</p><ul><li>通过Class对象的getDeclaredMethod(String name,Class … parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型；</li><li>之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息；</li></ul><p><strong><em>Object invoke(Object obj,Object … args)</em></strong></p><ul><li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li><li>若原方法为静态方法，此时形参Object obj可为null；</li><li>若原方法形参列表为空，则Object[] args 为null；</li><li>若原方法声明为private，则需要在调用此invoke方法之前，显式调用方法对象的setAccessible(true)方法，将可访问private方法。</li></ul><p>通过反射调用指定的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射操作属性</span></span><br><span class="line">User user2 = (User)c1.newInstance();</span><br><span class="line"></span><br><span class="line">Field name = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">name.setAccessible(<span class="keyword">true</span>); <span class="comment">// 因为name属性是私有属性，直接操作会报异常，所以现在关掉安全检测</span></span><br><span class="line">name.set(user2,<span class="string">"fym"</span>);</span><br><span class="line">System.out.println(user2.getName());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不能直接操作私有属性，我们需要关闭程序的安全检测；</span></span><br><span class="line"><span class="comment">    属性或者方法的setAccessible(true)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong><em>setAccessible</em></strong></p><ul><li>Method和Field、Constructor对象都有setAccessible方法；</li><li>setAccessible作用是启动和禁用访问安全检查的开关；</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查<ul><li>提高反射的效率。如果代码中必须使用反射，而该句代码需要频繁的被调用，那么请设置为true；</li><li>使得原本无法访问的私有成员也可以访问；</li></ul></li><li>参数值为false则指示反射的对象应该实施Java语言访问检查；</li></ul><p>我们来分析一下普通方式调用、反射方式调用、以及在关闭安全检测的情况下的反射调用这三种情况的性能，代码测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test10</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"普通方式执行1亿次: "</span>+(endtime-starttime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"反射方式执行1亿次"</span>+(endtime-starttime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用，关闭检测</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"关闭检测方式执行1亿次"</span>+(endtime-starttime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">    普通方式执行<span class="number">1</span>亿次: <span class="number">7</span>ms</span><br><span class="line">反射方式执行<span class="number">1</span>亿次<span class="number">4254</span>ms</span><br><span class="line">关闭检测方式执行<span class="number">1</span>亿次<span class="number">1863</span>ms</span><br></pre></td></tr></table></figure><p>从上面的输出结果可以看出，反射调用的方式对程序的运行效率影响很大，关闭安全检测后，可以提高的程序的运行效率，但这都和不使用反射方式的普通调用方式没法比的。</p><p>留下一个疑问：</p><p>Java反射机制既然可以直接Class对象，然后调用Class对象的newInstance方法或者通过构造器的newInstance方法创建一个实例对象，那么为什么不可以先强制类型转换然后再调用对象的方法，而非要通过getMethod方法和invoke方法进行对实例对象的方法的调用呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;获取运行时类的完整结构&quot;&gt;&lt;a href=&quot;#获取运行时类的完整结构&quot; class=&quot;headerlink&quot; title=&quot;获取运行时类的完整结构&quot;&gt;&lt;/a&gt;获取运行时类的完整结构&lt;/h4&gt;&lt;p&gt;通过反射获取运行时类的完整结构，Field、Method、Constructor、Superclass、Interface、Annotation，获取的操作都在java.lang.reflect包下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现的全部接口&lt;/li&gt;
&lt;li&gt;所继承的父类&lt;/li&gt;
&lt;li&gt;全部的构造器&lt;/li&gt;
&lt;li&gt;全部的方法&lt;/li&gt;
&lt;li&gt;全部的Field&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>反射机制</title>
    <link href="http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yxym.run/2020/03/30/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:27:54.668Z</updated>
    
    <content type="html"><![CDATA[<p>要了解反射机制，首先得了解一下什么是静态语言？什么是动态语言？</p><h4 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h4><ul><li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li><li>主要动态语言：Object-C、C#、JavaScript、Python等</li></ul><a id="more"></a><h4 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h4><ul><li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C</li><li>Java不是动态语言，但是Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制来获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</li></ul><h4 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h4><ul><li><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在<strong>执行期</strong>借助于Reflection API<strong>取得任何类的内部信息</strong>（包括类名、类的方法、类的接口、类的属性），并能直接操作任意对象的<strong>内部属性及方法</strong>。</p><p>​        <code>Class c1 = Class.forName(&quot;反射.User&quot;)</code></p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p></li></ul><p>正常方式：引入需要的“包类”名称  —-&gt;  通过new实例化  —-&gt;  取得实例化对象</p><p>反射方式：实例化对象  —-&gt;  getClass()方法  —-&gt;   得到完整的“包类”名称 </p><h5 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h5><ul><li><p>在运行时判断任意一个对象所属的类</p></li><li><p>在运行时构造任意一个类的对象</p></li><li><p>在运行时判断任意一个类所具有的成员变量和方法</p></li><li><p>在运行时获取泛型信息</p></li><li><p>在运行时调用任意一个对象的成员变量和方法</p></li><li><p>在运行时处理注解</p></li><li><p>生成动态代理</p><p>…..</p></li></ul><h5 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h5><p><strong>优点：</strong></p><ul><li>可以实现动态创建对象和编译，体现很大的灵活性</li></ul><p><strong>缺点：</strong></p><ul><li>对性能有影响，使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</li></ul><h4 id="反射相关的主要API"><a href="#反射相关的主要API" class="headerlink" title="反射相关的主要API"></a>反射相关的主要API</h4><ul><li><code>java.lang.Class</code> ：代表一个类</li><li><code>java.lang.reflect.Method</code> ：代表类的方法</li><li><code>java.lang.reflect.Field</code> ：代表类的成员变量</li><li><code>java.lang.reflect.Constructor</code> ：代表类的构造器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要了解反射机制，首先得了解一下什么是静态语言？什么是动态语言？&lt;/p&gt;
&lt;h4 id=&quot;动态语言&quot;&gt;&lt;a href=&quot;#动态语言&quot; class=&quot;headerlink&quot; title=&quot;动态语言&quot;&gt;&lt;/a&gt;动态语言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。&lt;/li&gt;
&lt;li&gt;主要动态语言：Object-C、C#、JavaScript、Python等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Class类</title>
    <link href="http://yxym.run/2020/03/30/Class%E7%B1%BB/"/>
    <id>http://yxym.run/2020/03/30/Class%E7%B1%BB/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:27:30.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在Object类中定义了以下的方法，此方法将被所有子类继承</p><p>​        <code>public final Class getClass()</code></p><p>这个方法的返回值类型是一个Class类，此类是Java反射的源头，是实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p><a id="more"></a><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（class、interface、enum、annotation、primitive type、void）的有关信息。</p><ul><li>Class本身也是一个类</li><li>Class对象只能由系统建立对象</li><li>一个加载的类在JVM中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li><strong>每个类的实例都会记得自己是由哪个Class实例所生成</strong></li><li>通过Class可以完整地得到一个类中的所有被加载结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。</li></ul><h4 id="Java中拥有Class对象的类型"><a href="#Java中拥有Class对象的类型" class="headerlink" title="Java中拥有Class对象的类型"></a>Java中拥有Class对象的类型</h4><p>在Java语言中，一切皆是对象。而对象主要分为两种，一种是普通类创建的实例对象，一种是Class类对象。每个类运行时的类型信息就是通过Class对象表示的，这个对象包含了与类有关的信息。其实<strong>Java中的实例对象就是通过Class对象来创建的</strong>，Java使用Class对象执行其RTTI（运行时类型识别，Run-Time Type Identification），多态是基于RTTI实现的。</p><p>那么在Java中哪些类型可以有Class对象呢？</p><ul><li>class：外部类、成员（成员内部类、静态内部类）、局部内部类、匿名内部类</li><li>interface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><p>我们用代码演示一下，这些类型的Class对象都是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 类</span></span><br><span class="line">Class c2 = Comparable<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 接口</span></span><br><span class="line">Class c3 = String[]<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 一维数组</span></span><br><span class="line">Class c4 = <span class="keyword">int</span>[][]<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 二维数组</span></span><br><span class="line">Class c5 = Override<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 注解</span></span><br><span class="line">Class c6 = ElementType<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 枚举</span></span><br><span class="line">Class c7 = Integer<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 基本数据类型（包装类）</span></span><br><span class="line">Class c10 = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 基本数据类型</span></span><br><span class="line">Class c8 = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 空类型</span></span><br><span class="line">Class c9 = Class<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// Class</span></span><br><span class="line"></span><br><span class="line">System.out.println(c1); <span class="comment">// class java.lang.Object</span></span><br><span class="line">System.out.println(c2); <span class="comment">// interface java.lang.Comparable</span></span><br><span class="line">System.out.println(c3); <span class="comment">// class [Ljava.lang.String;</span></span><br><span class="line">System.out.println(c4); <span class="comment">// class [[I</span></span><br><span class="line">System.out.println(c5); <span class="comment">// interface java.lang.Override</span></span><br><span class="line">System.out.println(c6); <span class="comment">// class java.lang.annotation.ElementType</span></span><br><span class="line">System.out.println(c7); <span class="comment">// class java.lang.Integer</span></span><br><span class="line">System.out.println(c10);<span class="comment">// int</span></span><br><span class="line">System.out.println(c8); <span class="comment">// void</span></span><br><span class="line">System.out.println(c9); <span class="comment">// class java.lang.Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于数组，只要元素类型与维度一样，就是同一个Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(a.getClass()); <span class="comment">//class [I</span></span><br><span class="line">System.out.println(b.getClass()); <span class="comment">//class [I</span></span><br><span class="line"></span><br><span class="line">System.out.println(b.getClass().hashCode()); <span class="comment">//1735600054</span></span><br><span class="line">System.out.println(a.getClass().hashCode()); <span class="comment">//1735600054</span></span><br></pre></td></tr></table></figure><p>​    <strong>每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象</strong>，更准确的来说，是被保存在一个<strong>同名的.class文件</strong>中。当程序中需要使用到这个类的时候(包括需要这个类的对象或引用这个类的静态变量)就通过类加载器将类加到内存中来。</p><p>​    Class类没有公共的构造方法，Class对象是在类加载的时候由<strong>Java虚拟机</strong>以及通过调用<strong>类加载器中的 defineClass 方法</strong>自动构造的，因此不能显式地声明一个Class对象。</p><h4 id="获取Class对象的方式有以下三种"><a href="#获取Class对象的方式有以下三种" class="headerlink" title="获取Class对象的方式有以下三种"></a>获取Class对象的方式有以下三种</h4><ol><li><code>Class.forName(“类的全限定名”)</code></li><li><code>实例对象.getClass()</code></li><li><code>类名.class （类字面常量）</code></li></ol><h5 id="Class-forName-和-实例对象-getClass"><a href="#Class-forName-和-实例对象-getClass" class="headerlink" title="Class.forName 和 实例对象.getClass()"></a>Class.forName 和 实例对象.getClass()</h5><p><code>Class.forName</code>方法是<code>Class</code>类的一个静态成员。<code>forName</code>在执行的过程中发现如果传入的参数类还没有被加载，那么JVM就会调用类加载器去加载这个参数类，并返回加载后的Class对象。<code>Class</code>对象和其他对象一样，我们可以获取并操作它的引用。在类加载的过程中，这个参数类的静态语句块会被执行。如果<code>Class .forName</code>找不到你要加载的类，它会抛出ClassNotFoundException异常。</p><p>静态语句块（static）在类第一次被加载的时候被执行，Class对象仅在需要的时候才会被加载。</p><p><code>Class.forName</code>的好处就在于，不需要为了获得<code>Class</code>引用而持有该类型的对象，只要通过全限定名就可以返回该类型的一个<code>Class</code>引用。如果你已经有了该类型的对象，那么我们就可以通过调用<code>getClass()</code>方法来获取<code>Class</code>引用了，这个方法属于根类<code>Object</code>的一部分，它返回的是表示该对象的实际类型的<code>Class</code>引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"反射.A"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">        Class b2 = b.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">My name is A</span></span><br><span class="line"><span class="comment">My name is B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，A和B这两个类都有一个静态语句块，所以当使用Class.forName和new关键字在执行以后，A和B分别会加载到内存中，当这两个类加载到内存以后，其内部的静态语句块便会被执行。与此同时，当用new关键字创建对象后，对应的实际创建这个对象的类已经装载到内存中了，所以执行getClass()方法的时候，就不会再去执行类加载的操作了，而是直接从java堆中返回该类型的Class引用。</p><h5 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h5><p>​    Java还提供了另一种方法来生成对Class对象的引用。即使用类字面常量，就像这样：Cat.class，这样做不仅更简单，而且更安全，因为它在编译时就会受到检查(因此不需要置于try语句块中)。并且根除了对forName()方法的调用，所有也更高效。类字面量不仅可以应用于普通的类，也可以应用于接口、数组及基本数据类型。</p><p>​    <strong>用.class来创建对Class对象的引用时，不会自动地初始化该Class对象</strong>（这点和Class.forName方法不同）。类对象的初始化阶段被延迟到了对静态方法或者<strong>非常数静态域</strong>首次引用时才执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            首先，调用class字面常量获取Class对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class b = B<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class a = A<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 此时发现并没有输出A和B这两个类的静态语句块的内容</span></span><br><span class="line">        <span class="comment">// 说明此时并不会自动初始化该Class对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">        System.out.println(B.s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          My name is A</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">My name is B</span></span><br><span class="line"><span class="comment">lalala</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String s = <span class="string">"lalala"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    发现当我们调用A和B的静态成员的时候，这两个类对象被初始化了，并且是先输出了静态语句块的内容，然后才在主程序中输出了两个静态成员变量的值。接下来我们将A类中的a变量改为常量<code>static final int a = 0;</code>，在主程序再次调用时发现A中的静态语句块并没被打印，说明引用常数静态成员并不会使类对象初始化。</p><p>​    也可以看出，如果仅使用.class语法来获得对类的Class引用是不会引发初始化的。但是如果使用Class.forName来产生引用，就会立即进行了初始化。</p><p>​    <strong>如果一个字段被static final修饰，我们称为”编译时常量“，就像A类的a字段那样，那么在调用这个字段的时候是不会对A类进行初始化的。</strong>因为被static和final修饰的字段，在编译期就把结果放入了常量池中了。但是，如果只是将一个域设置为static 或final的，还不足以确保这种行为，就如调用B的s字段后，会强制B进行类的初始化，因为s字段不是一个编译时常量。</p><p>​    一旦类被加载了到了内存中，那么不论通过哪种方式获得该类的Class对象，它们返回的都是<strong>指向同一个Java堆地址上的Class引用</strong>。JVM不会创建两个相同类型的Class对象。<strong>其实对于任意一个Class对象，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个Class对象来源于同一个Class文件，只要加载它们的类加载器不同，那这两个Class对象就必定不相等。</strong>这里的“相等”包括了代表类的Class对象的<code>equals（）、isAssignableFrom（）、isInstance（）</code>等方法的返回结果，也包括了使用<code>instanceof</code>关键字对对象所属关系的判定结果。所以在Java虚拟机中使用<strong>双亲委派模型</strong>来组织类加载器之间的关系，来保证Class对象的唯一性。</p><p>参考博客地址：</p><p><a href="https://blog.csdn.net/dufufd/article/details/80537638" target="_blank" rel="noopener">https://blog.csdn.net/dufufd/article/details/80537638</a></p><p><a href="https://blog.csdn.net/BraveLoser/article/details/82500474" target="_blank" rel="noopener">https://blog.csdn.net/BraveLoser/article/details/82500474</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;在Object类中定义了以下的方法，此方法将被所有子类继承&lt;/p&gt;
&lt;p&gt;​        &lt;code&gt;public final Class getClass()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方法的返回值类型是一个Class类，此类是Java反射的源头，是实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://yxym.run/2020/03/27/%E6%AD%BB%E9%94%81/"/>
    <id>http://yxym.run/2020/03/27/%E6%AD%BB%E9%94%81/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-27T03:27:16.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁基本概念"><a href="#死锁基本概念" class="headerlink" title="死锁基本概念"></a>死锁基本概念</h4><p>多个线程各自占有一些共享资源，并且互相等待获得其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源从而都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</p><a id="more"></a><h4 id="死锁的一个简单案例"><a href="#死锁的一个简单案例" class="headerlink" title="死锁的一个简单案例"></a>死锁的一个简单案例</h4><p>通过一个简单的例子，来说明一下产生死锁的情况：</p><p>案例：两个女孩都要化妆，但是只有一个口红和一面镜子，其中两个人各自拥有口红和镜子，但是二者在各自拥有口红和镜子的同时还拥有对方的资源，此时就产生了死锁，代码体现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份，用static来保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line">    <span class="keyword">int</span> choice; <span class="comment">// 选择</span></span><br><span class="line">    String girlname; <span class="comment">// 使用化妆品的人</span></span><br><span class="line">    Makeup(<span class="keyword">int</span> choice,String girlname)&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.girlname = girlname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 化妆，互相持有对方的锁，就是需要拿到对方的资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得口红的锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 一秒钟之后，想获得镜子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得镜子的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得镜子的锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 两秒钟之后，想获得口红</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得口红的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如何解决呢？就是不能抱着对方的锁，不让两个对象同时抱着一把锁就可以了,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (choice==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lipstick)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得口红的锁"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 一秒钟之后，想获得镜子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得镜子的锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mirror)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得镜子的锁"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 两秒钟之后，想获得口红</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lipstick)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.girlname+<span class="string">"获得口红的锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h4><p>1.互斥条件：一个资源每次只能被一个进程使用；</p><p>2.请求与保持条件：一个进程因请求资源而阻塞时，对已经获得的资源保持不放；</p><p>3.不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；</p><p>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系；</p><p>以上四种死锁的四个必要条件，我们只要想办法破解其中的任意一个或者多个条件就可以避免死锁发生。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁基本概念&quot;&gt;&lt;a href=&quot;#死锁基本概念&quot; class=&quot;headerlink&quot; title=&quot;死锁基本概念&quot;&gt;&lt;/a&gt;死锁基本概念&lt;/h4&gt;&lt;p&gt;多个线程各自占有一些共享资源，并且互相等待获得其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源从而都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程的Lock锁</title>
    <link href="http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8BLock%E9%94%81/"/>
    <id>http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8BLock%E9%94%81/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-27T03:27:56.459Z</updated>
    
    <content type="html"><![CDATA[<ul><li>从JDK5.0开始，Java提供了更强大的线程同步机制—-通过显示定义同步锁对像来实现同步。同步锁使用Lock对象充当。</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li></ul><a id="more"></a><h4 id="Lock锁的一个使用代码模板"><a href="#Lock锁的一个使用代码模板" class="headerlink" title="Lock锁的一个使用代码模板"></a>Lock锁的一个使用代码模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 保证线程安全的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line"><span class="comment">// 如果同步代码有异常，要将unlock()写入finally语句块。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="使用Lock的案例"><a href="#使用Lock的案例" class="headerlink" title="使用Lock的案例"></a>使用Lock的案例</h4><p> 测试一个使用Lock锁的例子，还是以一个抢票的例子来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试Lock锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticketnums = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticketnums &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketnums--);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁,如果同步代码部分有异常，把解锁代码卸载finally代码块里面。</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lock锁来保证对ArrayList并发添加元素时的数据安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized-与-Lock的对比"><a href="#synchronized-与-Lock的对比" class="headerlink" title="synchronized 与 Lock的对比"></a>synchronized 与 Lock的对比</h4><ul><li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁出了作用域自动释放。</p></li><li><p>Lock只有代码块锁，synchronized有代码锁和方法锁。</p></li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p></li><li><p>优先使用顺序：</p><p>​    Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt;  同步方法（在方法体之外）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;从JDK5.0开始，Java提供了更强大的线程同步机制—-通过显示定义同步锁对像来实现同步。同步锁使用Lock对象充当。&lt;/li&gt;
&lt;li&gt;java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。&lt;/li&gt;
&lt;li&gt;ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-27T03:28:47.558Z</updated>
    
    <content type="html"><![CDATA[<p>并发：同一个对象被多个线程同时操作。</p><p>现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题，比如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队，一个一个来。</p><a id="more"></a><p>处理多线程问题时，<strong>多个线程访问同一个对象</strong>，并且某些线程还想修改这个对象，这时我们就需要线程同步。</p><p><strong>线程同步其实就是一种等待机制</strong>，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。</p><p>线程同步的形成条件是：队列+锁 ; 每个对象都有一个锁，保证线程同步安全</p><p>由于同一个进程的多个线程共享一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制synchronized</strong>。</p><p>当一个线程获得对象的<strong>排它锁</strong>，独占资源，其他线程必须等待，使用后释放锁即可。所以也会存在以下问题：</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。</li></ul><h4 id="线程不安全举例"><a href="#线程不安全举例" class="headerlink" title="线程不安全举例"></a>线程不安全举例</h4><p>第一个例子：使用循环创建10000个线程向ArrayList集合添加元素，但是实际集合的大小肯能会小于10000</p><pre><code>// 线程不安全的集合public class UnsafeList {    public static void main(String[] args) {        List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();        for(int i = 0;i &lt; 10000;i++){            new Thread(()-&gt;{                stringArrayList.add(Thread.currentThread().getName());            }).start();        }        System.out.println(stringArrayList.size());        /*            不安全的原因就是某几个线程在同一时间在集合中的同一位置添加了元素            产生不安全的来源就是线程都有各自的工作内存，所以当他们看到资源对象的某个资源时会将资源同时拷贝到自己的工作内存中            从而导致数据的不一致性         */    }}</code></pre><p>第二个例子：模拟不安全买票</p><pre><code>// 不安全买票// 线程不安全，有负数public class UnsafeBuyTicket {    public static void main(String[] args) {        BuyTicket station = new BuyTicket();        new Thread(station,&quot;苦逼的我&quot;).start();        new Thread(station,&quot;啦了&quot;).start();        new Thread(station,&quot;了啦&quot;).start();        /*            此时启动线程后，发现有人买到了值为“负数”的票，说明了线程不安全，这是为什么呢？                每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。比如，当还有一张票的时候，                三个线程同时看到了这个“1”，此时就会将1放入各自的工作内存中，因此就会产生-1的错误值。         */    }}class BuyTicket implements Runnable{    // ticket    int ticketNums = 10;    boolean flag = true; // 外部停止方式    @Override    public void run() {        // 买票        while (flag){            buy();        }    }    private void buy(){        // 判断是否有票        if (ticketNums &lt;= 0){            flag = false;        }        // 模拟延时,放大问题的发生性        try {            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }        // 买票        System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNums--);    }}</code></pre><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，<br>它包括两种用法：synchronized方法和synchronized块．</p><p>1、同步方法：</p><pre><code>public synchronized void method(int args){}</code></pre><p>synchronized方法控制对＂对象＂的访问，<strong>每个对象对应一把锁</strong>，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，<br>方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。</p><p>缺陷：如果将一个大的方法申明为synchronized将会影响效率。方法里面需要修改的内容才需要锁，锁的太多，浪费资源。</p><p>2、同步块</p><ul><li>同步块：synchronized(Obj){}</li><li>Obj称之为同步监视器<ul><li>Obj可以是任何对象，但是推荐使用<strong>共享资源（需要变化的对象，增删）</strong>作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。</li></ul></li><li>同步监视器的执行过程<ul><li>第一个线程访问，锁定同步监视器，执行其中代码；</li><li>第二个线程访问，发现同步监视器被锁定，无法访问；</li><li>第一个线程访问完毕，解锁同步监视器；</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li></ul></li></ul><p>针对前面三个线程不安全的案例，这里我们使用同步方法和同步块来改进，使得线程安全：</p><p>1、第一个案例，买票，使用同步方法，主要是对buy方法加上同步锁，因为只要调用buy方法时，才会改变票数</p><pre><code>// synchronized 同步方法，锁的是this，即该对象本身private synchronized void  buy(){    // 判断是否有票    if (ticketNums &lt;= 0){        flag = false;        return;    }    // 模拟延时,放大问题的发生性    try {        Thread.sleep(100);    } catch (InterruptedException e) {        e.printStackTrace();    }    // 买票    System.out.println(Thread.currentThread().getName()+&quot;拿到&quot;+ticketNums--);}</code></pre><p>因为只有一个线程对象，所以这里使用同步方法可以解决线程不安全的问题<br>2、银行取钱</p><p>这个案例，存在两个线程对象，所以如果使用同步方法，并不能保证数据一致性，因为此时这个同步方法锁的是this，<br>即取钱对象，而为了保证数据的一致性，应该锁上银行账户对象，因为银行对象是变化的对象，只有锁上它，才能保证数据的一致性。</p><p><strong>synchronized默认锁的是this。</strong></p><p>这里我们使用同步块：</p><pre><code>public void run() {    /*    * 这里使用synchronized块的方式对共享资源进行上锁，从而保证数据的一致性    * 锁的对象就是变化的量，需要增删的对象    * */    synchronized (account){        // 判断没有钱        if (account.money - drawingMoney &lt; 0){            System.out.println(Thread.currentThread().getName()+&quot;钱不够，取不了&quot;);            return;        }        // sleep可以放大问题的发生性        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        // 卡内余额 = 余额 - 你取的钱        account.money = account.money - drawingMoney;        nowMoney = nowMoney + drawingMoney;        System.out.println(account.name+&quot;余额为：&quot;+account.money);        // Thread.currentThread().getName() 等价于 this.getName()        // 因为该类继承了Thread类，也就继承了Thread的全部方法        System.out.println(this.getName()+&quot;手里的钱：&quot;+nowMoney);    }}</code></pre><p>3、第三个案例，集合，也是使用同步块，因为变化的对象是集合对象，所以锁的也是集合对象。</p><pre><code>List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();for(int i = 0;i &lt; 10000;i++){    new Thread(()-&gt;{        synchronized (stringArrayList){            stringArrayList.add(Thread.currentThread().getName());        }    }).start();}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发：同一个对象被多个线程同时操作。&lt;/p&gt;
&lt;p&gt;现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题，比如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队，一个一个来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程协作</title>
    <link href="http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/"/>
    <id>http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-26T16:46:15.651Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><h5 id="应用场景：生产者消费者问题"><a href="#应用场景：生产者消费者问题" class="headerlink" title="应用场景：生产者消费者问题"></a>应用场景：生产者消费者问题</h5><ul><li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费；</li><li>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止；</li><li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li></ul><a id="more"></a><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>生产者和消费者模式,它不是一种设计模式，而是一种解决由多线程引发的同步问题的办法，也称为有限缓冲问题。这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件。而解决问题的关键就是，使消费者和生产者<strong>同时只能有一个线程访问这块缓存</strong>，也就是说它们之间是互斥的。</p><ul><li>对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费；</li><li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费；</li><li>在生产者消费者问题中，仅有synchronized是不够的<ul><li>synchronized可阻止并发更新同一个共享资源，实现了同步；</li><li>synchronized不能用来实现不同线程之间的消息传递（通信）。</li></ul></li></ul><p>Java提供了几个方法解决线程之间的通信问题</p><table><thead><tr><th align="center">方法名字</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">wait()</td><td align="center">表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td></tr><tr><td align="center">wait(long timeout)</td><td align="center">指定等待的毫秒数</td></tr><tr><td align="center">notify()</td><td align="center">唤醒一个处于等待状态的线程（同一个对象上）</td></tr><tr><td align="center">notifyAll()</td><td align="center">唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td></tr></tbody></table><p>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常。</p><h5 id="解决方式一：管程法"><a href="#解决方式一：管程法" class="headerlink" title="解决方式一：管程法"></a>解决方式一：管程法</h5><p>并发协作模型：生产者/消费者模式</p><ul><li>生产者：负责生产数据的模块（可能是方法、对象、线程、进程）</li><li>消费者：负责处理数据的模块（可能是方法、对象、线程、进程）</li><li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个”缓冲区”</li></ul><p>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。</p><p>实际应用案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试：生产者消费者模型---》利用缓冲区解决：管程法</span></span><br><span class="line"><span class="comment">    生产者、消费者、产品、缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC_GC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者，只负责生产</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> Chicken(i));</span><br><span class="line">            System.out.println(<span class="string">"生产了"</span>+i+<span class="string">"只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者，只负责消费</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费了"</span>+container.pop().id+<span class="string">"只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要一个容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == chickens.length)&#123;</span><br><span class="line">            <span class="comment">// 通知消费者消费，生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有满,就需要丢入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通知消费者消费了</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        Chicken chicken = chickens[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 吃完了，通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决方式二：信号灯法"><a href="#解决方式二：信号灯法" class="headerlink" title="解决方式二：信号灯法"></a>解决方式二：信号灯法</h5><p>并发协作模型：生产者消费者模式</p><ul><li><p>设置一个标识位flag；</p></li><li><p>当标识为真的时候消费者消费，生产者等待；</p></li><li><p>当标识为假的时候，生产者生产，消费者等待。</p></li></ul><p>实际的应用案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试：生产者消费者模型---》利用缓冲区解决：信号灯法，标志位解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC_Singal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者--&gt;演员，只负责表演</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"琅琊榜"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"伪装者"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者--&gt;观众，只负责观看</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品--&gt;节目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="comment">// 演员表演，观众等待</span></span><br><span class="line">    <span class="comment">// 观众观看，演员等待</span></span><br><span class="line">    String voice;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"演员表演了："</span>+voice);</span><br><span class="line">        <span class="comment">//通知观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notify(); <span class="comment">// 通知唤醒</span></span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"观看了:"</span>+<span class="keyword">this</span>.voice);</span><br><span class="line">        <span class="comment">//通知演员表演了</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要记得生产者和消费者是相互依赖的，而且双方在同一时刻是互斥的，当生产者生产了产品之后要立马通知消费者消费，当消费者消费完一个产品之后，要立马告诉生产者进行生产。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线程通信&quot;&gt;&lt;a href=&quot;#线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程通信&quot;&gt;&lt;/a&gt;线程通信&lt;/h4&gt;&lt;h5 id=&quot;应用场景：生产者消费者问题&quot;&gt;&lt;a href=&quot;#应用场景：生产者消费者问题&quot; class=&quot;headerlink&quot; title=&quot;应用场景：生产者消费者问题&quot;&gt;&lt;/a&gt;应用场景：生产者消费者问题&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费；&lt;/li&gt;
&lt;li&gt;如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止；&lt;/li&gt;
&lt;li&gt;如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yxym.run/2020/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-27T03:25:59.223Z</updated>
    
    <content type="html"><![CDATA[<ul><li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li><li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池子中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li><li>好处：<ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTIme：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul><a id="more"></a><h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><ul><li>JDK5.0开始提供了线程池相关的API：ExecutorService和Executors</li><li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul><li>void execute(Runnable command):执行任务/命令，没有返回值，一般用来执行Runnable</li><li><T> Future <T> submit(Callable<T> task):执行任务，有返回值，一般用来执行Callable</li><li>void shutdown():关闭连接池</li></ul></li><li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</li></ul><h4 id="代码应用"><a href="#代码应用" class="headerlink" title="代码应用"></a>代码应用</h4><p>1.使用execute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">// newFixedThreadPool参数为池子大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.关闭链接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用submit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载图片线程的执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable testThread1 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        TestCallable testThread2 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        TestCallable testThread3 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务,此处new了一个池子，现在在池子中放入三个线程</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行,submit方法有返回值</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = ser.submit(testThread1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = ser.submit(testThread2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = ser.submit(testThread3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean rs1 = result1.get();</span><br><span class="line">        Boolean rs2 = result2.get();</span><br><span class="line">        Boolean rs3 = result3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。&lt;/li&gt;
&lt;li&gt;思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池子中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。&lt;/li&gt;
&lt;li&gt;好处：&lt;ul&gt;
&lt;li&gt;提高响应速度（减少了创建新线程的时间）&lt;/li&gt;
&lt;li&gt;降低资源消耗（重复利用线程池中的线程，不需要每次都创建）&lt;/li&gt;
&lt;li&gt;便于线程管理&lt;ul&gt;
&lt;li&gt;corePoolSize：核心池的大小&lt;/li&gt;
&lt;li&gt;maximumPoolSize：最大线程数&lt;/li&gt;
&lt;li&gt;keepAliveTIme：线程没有任务时最多保持多长时间后会终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>守护线程</title>
    <link href="http://yxym.run/2020/03/27/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yxym.run/2020/03/27/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2020-03-27T03:26:40.546Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>如，后台记录操作日志，监控内存，垃圾回收等待…</li></ul><a id="more"></a><p>测试代码：</p><pre><code>// 测试守护线程public class TestDaemon {    public static void main(String[] args) {        God god = new God();        You you = new You();        Thread thread = new Thread(god);        thread.setDaemon(true); // 默认是false表示是用户线程，正常的线程都是用户线程...        thread.start(); // 守护线程启动        new Thread(you).start(); // 用户线程启动        /*            只要用户线程执行完毕即可，虚拟机不用等待守护线程执行完毕         */    }}class God implements Runnable{    @Override    public void run() {        while (true){            System.out.println(&quot;上帝保佑你！&quot;);        }    }}class You implements Runnable{    @Override    public void run() {        for (int i = 0; i &lt; 36500; i++) {            System.out.println(&quot;你一生都开心的活着&quot;);        }        System.out.println(&quot;-======goodbye! world!========&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;线程分为&lt;strong&gt;用户线程&lt;/strong&gt;和&lt;strong&gt;守护线程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚拟机必须确保用户线程执行完毕&lt;/li&gt;
&lt;li&gt;虚拟机不用等待守护线程执行完毕&lt;/li&gt;
&lt;li&gt;如，后台记录操作日志，监控内存，垃圾回收等待…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线程状态</title>
    <link href="http://yxym.run/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://yxym.run/2020/03/23/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2020-03-27T03:33:26.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-停止线程"><a href="#1-停止线程" class="headerlink" title="1.停止线程"></a>1.停止线程</h4><ul><li><p>不推荐使用JDK提供的stop、destroy方法，这些方法已经被废弃了</p></li><li><p>推荐线程自己停止下来</p></li><li><p>建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。</p><a id="more"></a><p>代码示例：</p><p>  /*</p><pre><code>测试stop    1.建议线程正常停止---&gt;利用次数，不建议死循环    2.建议使用标志位---&gt;设置一个标志位    3.不要使用stop或者destroy等过时或者JDK不建议使用的方法</code></pre><p>   */<br>  public class TestStop implements Runnable{</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">        System.out.println(<span class="string">"run....Thread"</span>+(i++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置一个公开的方法停止线程，转换标志位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">    <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"main thread "</span>+i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">900</span>)&#123;</span><br><span class="line">            testStop.stop();</span><br><span class="line">            System.out.println(<span class="string">"线程该停止了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p></li></ul><h4 id="2-线程休眠"><a href="#2-线程休眠" class="headerlink" title="2.线程休眠"></a>2.线程休眠</h4><ul><li>sleep(时间) 指定当前线程阻塞的毫秒数</li><li>sleep存在异常InterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时，倒计时等。</li><li>每一个对象都有一个锁，sleep不会释放锁</li></ul><p>1.模拟网络延时，可以放大问题的发生性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketnum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticketnum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentThread()方法是获取当前正在执行的线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;拿到了第"</span>+ticketnum--+<span class="string">"票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSleep ticket = <span class="keyword">new</span> TestSleep();</span><br><span class="line">        <span class="comment">// 三个进程共享一个对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"小花"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序中，三个线程共享一个资源对象，这三个线程可能会发生线程不安全的问题，比如某个线程抢到第-1张票，通过线程休眠，可以将这些问题反映出来。</p><p>2.模拟倒计时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 打印当前系统时间</span></span><br><span class="line">        Date startTime = <span class="keyword">new</span> Date(System.currentTimeMillis()); <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(startTime));</span><br><span class="line">                startTime = <span class="keyword">new</span> Date(System.currentTimeMillis()); <span class="comment">// 更新当前时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tenDown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(num--);</span><br><span class="line">            <span class="keyword">if</span> (num&lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-线程礼让"><a href="#3-线程礼让" class="headerlink" title="3.线程礼让"></a>3.线程礼让</h4><ul><li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>礼让是让当前正在执行的线程变为就绪状态，与其他线程重新竞争CPU资源，让CPU重新调度，礼让不一定成功，看CPU心情</li></ul><p>礼让示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试礼让，礼让不一定成功</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程开始执行"</span>);</span><br><span class="line">        Thread.yield(); <span class="comment">// 礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程停止执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输出如下结果时，说明没有礼让成功：</p><pre><code>a线程开始执行a线程停止执行b线程开始执行b线程停止执行</code></pre><p>当输出下面的结果时，说明礼让成功了</p><pre><code>a线程开始执行b线程开始执行a线程停止执行b线程停止执行</code></pre><h4 id="4-Join"><a href="#4-Join" class="headerlink" title="4.Join"></a>4.Join</h4><ul><li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li><li>可以想象成插队</li></ul><p>测试Join方法，想象为插队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程vip来了"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动我们的线程</span></span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        <span class="comment">// 开启子线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">200</span>)&#123;</span><br><span class="line">                thread.join(); <span class="comment">// 插队，子线程插主线程的队</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h4><p>线程可以处于以下状态之一：</p><ul><li><p>NEW</p><pre><code>尚未启动的线程处于此状态</code></pre></li><li><p>RUNNABLE</p><pre><code>在Java虚拟机中执行的线程处于此状态</code></pre></li><li><p>BLOCKED</p><pre><code>被阻塞等待监视器锁定的线程处于此状态</code></pre></li><li><p>WAITING</p><pre><code>正在等待另一个线程执行特定动作的线程处于此状态</code></pre></li><li><p>TIMED_WAITING</p></li></ul><pre><code>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</code></pre><ul><li><p>TERMINATED</p><pre><code>已退出的线程处于此状态</code></pre><p>一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。</p></li></ul><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察测试线程状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"////////"</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 观察状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state); <span class="comment">// 此时状态为NEW</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察启动后</span></span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state); <span class="comment">// 此时线程状态为RUNNABLE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED)&#123; <span class="comment">// 只要线程不终止，就一直输出状态</span></span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            state = thread.getState(); <span class="comment">// 更新state变量的存储的线程状态</span></span><br><span class="line">            System.out.println(state); <span class="comment">// 输出状态，TIMED_WAITING</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-停止线程&quot;&gt;&lt;a href=&quot;#1-停止线程&quot; class=&quot;headerlink&quot; title=&quot;1.停止线程&quot;&gt;&lt;/a&gt;1.停止线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不推荐使用JDK提供的stop、destroy方法，这些方法已经被废弃了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推荐线程自己停止下来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Lamda表达式</title>
    <link href="http://yxym.run/2020/03/23/lamda/"/>
    <id>http://yxym.run/2020/03/23/lamda/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2020-03-23T14:53:40.693Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要使用lambda表达式：</p><ul><li>避免匿名内部类定义过多</li><li>可以让代码看起来更简洁</li><li>去掉一堆没有意义的代码，只留下核心的逻辑<a id="more"></a>函数式接口(Functional Interface)</li></ul><p>定义：任何接口，如果只包含<strong>唯一一个</strong>抽象方法，那么它就是一个函数式接口。</p><p>例如：</p><pre><code>public interface Runnable{    public abstract void run();}</code></pre><p>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p><p>lamda表达式的实质属于函数式编程的概念</p><pre><code>(params) -&gt; expression [表达式](params) -&gt; statement [语句](params) -&gt; {statements}</code></pre><p>下面通过一个例子来展示一下，如何使用lambda表达式来简化代码：</p><p>首先定义一个函数式接口，注意函数式接口中，只能有唯一一个抽象方法：</p><pre><code>interface ILove{    void love(int a);}</code></pre><p>然后，我们实现这个接口的方式有以下几种：</p><pre><code>// 第一种，通过外部实现类class Love1 implements ILove{    @Override    public void love(int a) {        System.out.println(&quot;外部类 &quot;+a);    }}public class Testlamda2 {    static class Love2 implements ILove{        @Override        public void love(int a) {            System.out.println(&quot;静态内部类 &quot;+a);        }    }    public static void main(String[] args) {        //外部类        ILove iLove = new Love1();        iLove.love(1);        //静态内部类        iLove = new Love2();        iLove.love(2);        //局部内部类        class Love3 implements ILove{            @Override            public void love(int a) {                System.out.println(&quot;局部内部类 &quot;+a);            }        }        iLove = new Love3();        iLove.love(3);        //匿名内部类        iLove = new ILove() {            @Override            public void love(int a) {                System.out.println(&quot;匿名内部类&quot;+a);            }        };        iLove.love(4);        //lambda表达式        iLove = (int a) -&gt; {            System.out.println(&quot;lambda表达式&quot;+a);        };        iLove.love(5);    }}</code></pre><p>还可以对上面的lambda表达式进行简化：</p><pre><code>//简化1.去掉参数类型iLove = (a)-&gt;{    System.out.println(&quot;简化lambda表达式&quot;+a);};iLove.love(6);//简化2.简化括号iLove = a-&gt;{    System.out.println(&quot;简化lambda表达式&quot;+a);};iLove.love(7);//简化3.去掉花括号iLove = a -&gt; System.out.println(&quot;简化lambda表达式&quot;+a);iLove.love(8);</code></pre><p>总结：</p><ul><li>lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹</li><li>前提是接口为函数式接口</li><li>多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要使用lambda表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免匿名内部类定义过多&lt;/li&gt;
&lt;li&gt;可以让代码看起来更简洁&lt;/li&gt;
&lt;li&gt;去掉一堆没有意义的代码，只留下核心的逻辑
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线程基本概念与创建</title>
    <link href="http://yxym.run/2020/03/23/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    <id>http://yxym.run/2020/03/23/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</id>
    <published>2020-03-22T16:00:00.000Z</published>
    <updated>2020-03-27T03:34:26.589Z</updated>
    
    <content type="html"><![CDATA[<p>进程是代码在数据集合上的一次活动，是系统进行资源分配和调度的基本单位。而线程则是进程的一个执行路径，一个进程至少有一个线程。<br>进程中的多个线程共享进程的资源。</p><a id="more"></a><p>操作系统在分配资源时是把资源分配给进程的，但CPU资源比较特殊，是分配到线程的，因为真正占用CPU运行的是线程，所以说线程是CPU分配的基本单位。</p><p>关于线程需要知道：</p><ul><li>线程是独立的执行路径</li><li>程序运行时，即使自己没有创建线程，后台也会有多个线程</li><li>main()称之为主线程，是系统的入口</li><li>进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器与操作系统密切相关，先后顺序无法人为ie干预</li><li>对同一资源操作时，会发生资源抢夺问题，应加入并发控制</li><li>线程会带来额外开销，如CPU调度时间</li><li>每个线程在自己的工作内存进行交换，内存控制不当会造成数据不一致。</li></ul><p>在Java语言中，创建线程的方式一共有三种，分别是继承Thread类、实现Runnable接口，实现Callable接口。下面分别阐述。</p><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>通过继承Thread类，创建线程的方式有以下几个步骤：</p><ul><li>自定义线程类继承Thread类</li><li>重写run方法，编写线程执行体</li><li>创建线程对象，调用start方法启动线程</li></ul><p>子类继承Thread类具备多线程能力</p><p>启动线程，子类对象.start()</p><p>不建议使用：避免OOP单继承局限性</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程创建的第一个方式：</span></span><br><span class="line">    继承Thread类;</span><br><span class="line">    重写run方法，编写线程执行体;</span><br><span class="line">    创建线程对象，调用start方法启动线程</span><br><span class="line"><span class="comment">// 总结：注意，线程开启不一定立即执行，由CPU调度执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码--"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main thread</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread th = <span class="keyword">new</span> TestThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法开启线程，主线程和子线程会交替执行，所以打印的结果是交替打印出来的</span></span><br><span class="line">        th.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程--"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>通过实现Runnable接口，创建线程的方式过程如下：</p><ul><li>定义MyRunnable类实现Runnable接口</li><li>实现run方法，编写线程执行体</li><li>创建线程对象，调用start方法启动线程</li></ul><p>实现接口Runnable具有多线程能力</p><p>启动线程：传入目标对象+Thread对象.start()</p><p>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一份资源</span></span><br><span class="line">TestThread2 testThread = <span class="keyword">new</span> TestThread2(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个代理</span></span><br><span class="line"><span class="keyword">new</span> Thread(testThread,<span class="string">"Tom"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(testThread,<span class="string">"Job"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(testThread,<span class="string">"Bob"</span>).start();</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口创建线程的小demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式2：</span></span><br><span class="line">    实现runnable接口;</span><br><span class="line">    重写run方法;</span><br><span class="line">    执行线程需要丢入runnable接口实现类，调用start方法</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 推荐使用runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码--"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建runnable接口的实现类对象</span></span><br><span class="line">        RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnableTest);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            new Thread(runnableTest).start();</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure><p>​<br>​            for (int i = 0; i &lt; 20; i++) {<br>​                System.out.println(“我在学习多线程–”+i);<br>​            }<br>​        }<br>​    }</p><h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h4><p>线程创建方式三：实现Callable接口</p><p>Callable的好处：</p><pre><code>1.可以定义返回值2.可以抛出异常</code></pre><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载图片线程的执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable testThread1 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        TestCallable testThread2 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        TestCallable testThread3 = <span class="keyword">new</span> TestCallable(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务,此处new了一个池子，现在在池子中放入三个线程</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; result1 = ser.submit(testThread1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = ser.submit(testThread2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = ser.submit(testThread3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean rs1 = result1.get();</span><br><span class="line">        Boolean rs2 = result2.get();</span><br><span class="line">        Boolean rs3 = result3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程是代码在数据集合上的一次活动，是系统进行资源分配和调度的基本单位。而线程则是进程的一个执行路径，一个进程至少有一个线程。&lt;br&gt;进程中的多个线程共享进程的资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="http://yxym.run/categories/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第38题</title>
    <link href="http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC38%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC38%E9%A2%98/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-19T15:52:16.498Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><pre><code>　　1.     1　　2.     11　　3.     21　　4.     1211　　5.     111221</code></pre><p>1 被读作 “一个一”, 即 11。<br>11 被读作 “两个一”, 即 21。<br>21 被读作”一个二” ,  “一个一”, 即 1211</p><a id="more"></a><p>要求：</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>解题思路：</p><p>　　从题目中的信息可以知道，当我们想要求第n项的结果时，需要先知道第n-1项的字符串;想要求出第n-1项的结果时，必须先知道第n-2项的结果……以此类推，推到第1项，第一项的结果正是”1”。所以想求第n项的结果时，可以从第一项以此往后递推。解决此题，可以使用演绎法、递归法、以及使用栈。</p><p>第一种解法：使用演绎法</p><p>describe函数是针对”上一个“结果项进行分析，然后分析求出下一个结果项的样子。</p><pre><code>public String countAndSay(int n) {    String num = &quot;1&quot;;    for (int i = 0; i &lt; n - 1; i++) {        num = describe(num.toCharArray());    }    return num;}public static String describe(char[] chars){    StringBuilder string = new StringBuilder();    char ch = chars[0];    int temp = 1,i = 1;    while(i &lt; chars.length){        if (chars[i] == ch)            temp++;        else{            string.append(temp).append(chars[i-1]);            ch = chars[i];            temp = 1;        }        i++;    }    string.append(temp).append(chars[i - 1]);    return string.toString();}</code></pre><p>第二种解法：递归</p><p>递归与上面第一种解法几乎相同，唯一不同的就是上面用的是循环，而此处采用递归的方式。</p><pre><code>// 递归用法public String countAndSay4(int n) {    if (n == 1)        return &quot;1&quot;;    return describe(countAndSay4(n - 1).toCharArray());}public static String describe(char[] chars){    StringBuilder string = new StringBuilder();    char ch = chars[0];    int temp = 1,i = 1;    while(i &lt; chars.length){        if (chars[i] == ch)            temp++;        else{            string.append(temp).append(chars[i-1]);            ch = chars[i];            temp = 1;        }        i++;    }    string.append(temp).append(chars[i - 1]);    return string.toString();}</code></pre><p>第三种解法：使用栈</p><p>栈中存储的都是相同的元素，因此栈中元素个数就表示有几个栈中元素。内循环结束之后，还有进行一次append操作是为了将出现在末尾的连续数字结果进行保存。</p><pre><code>public String countAndSay3(int n){    if (n==1)        return &quot;1&quot;;    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();    StringBuilder string;    String res = &quot;1&quot;;    for (int i = 1; i &lt; n; i++) {        stack.clear();        string  = new StringBuilder();        char[] chars = res.toCharArray();        for (int j = 0;j &lt; chars.length;j++){            if (stack.isEmpty() || stack.peek() == chars[j]){                stack.push(chars[j]);            }else {                string.append(stack.size()).append(stack.peek());                stack.clear();                stack.push(chars[j]);            }        }        string.append(stack.size()).append(stack.peek());        res = string.toString();    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;　　1.     1
　　2.     11
　　3.     21
　　4.     1211
　　5.     111221&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1 被读作 “一个一”, 即 11。&lt;br&gt;11 被读作 “两个一”, 即 21。&lt;br&gt;21 被读作”一个二” ,  “一个一”, 即 1211&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第35题</title>
    <link href="http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC35%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/19/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC35%E9%A2%98/</id>
    <published>2020-03-18T16:00:00.000Z</published>
    <updated>2020-03-19T15:52:28.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><a id="more"></a><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>最直接的想法就是使用二分查找，如果有序数组中含有与target值相等的元素，直接返回对应的索引值;如果没有则在查找完毕之后，返回对应的左游标值。还有一种解法是直接遍历有序数组，遍历进行的条件是数组当前访问值小于target值同时遍历游标小于数组长度，遍历结束后，对应的遍历游标值就是应该要返回的值。</p><h4 id="第一种解法：二分查找"><a href="#第一种解法：二分查找" class="headerlink" title="第一种解法：二分查找"></a>第一种解法：二分查找</h4><p>时间复杂度为：O(logn)</p><p>我在评论中看到关于计算mid值的争议，有人说直接mid = (left + right) / 2是不安全的，可能会溢出，所以一种比较安全的写法是 mid = left + (right - left) / 2; 就好比是超过10就会发生溢出，现在有两个值，一个为6,一个为8,如果直接计算，则6+8=14&gt;10，会发生溢出，但是通过mid = left + (right - left) / 2公式进行计算 mid = 6 + (8-6)/2,就避免了这个问题，挺有道理，所以借鉴了。</p><pre><code>public int searchInsert(int[] nums, int target) {        if (nums.length == 0 || (target &lt; nums[0]))            return 0;        if (target &gt; nums[nums.length-1])            return nums.length;        if (nums.length == 1){            if (target&gt;nums[0])                return 1;            else                return 0;        }        int left = 0;        int right = nums.length - 1;        int mid = (left + right) / 2;        while (left &lt;= right){            if (nums[mid] == target)                return mid;            else if (nums[mid] &gt; target){                right = mid - 1;            }else {                left = mid + 1;            }            mid = (right + left) / 2;        }        return mid + 1;    }</code></pre><h4 id="第一种解法续：对二分查找的改进，减少循环次数"><a href="#第一种解法续：对二分查找的改进，减少循环次数" class="headerlink" title="第一种解法续：对二分查找的改进，减少循环次数"></a>第一种解法续：对二分查找的改进，减少循环次数</h4><p>这是我在题解的评论中看到有人提供的解法，思路可以借鉴，虽然运行速度并没有我的快，哈哈哈哈</p><pre><code>public int searchInsert3(int[] nums,int target){    int lo=0,hi=nums.length;    while(lo&lt;hi-1){        int mid=(lo+hi)&gt;&gt;1;        if(target&lt;nums[mid])            hi=mid;        else            lo=mid;    }    return target&lt;=nums[lo]? lo:++lo;}</code></pre><h4 id="第二种解法：暴力遍历"><a href="#第二种解法：暴力遍历" class="headerlink" title="第二种解法：暴力遍历"></a>第二种解法：暴力遍历</h4><p>超级简短，时间复杂度为O(n)</p><pre><code>public int searchInsert2(int[] nums, int target) {    int i;    for(i=0;i&lt;nums.length&amp;&amp;nums[i]&lt;target;i++);    return i;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h4&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>可变参数</title>
    <link href="http://yxym.run/2020/03/09/varargs/"/>
    <id>http://yxym.run/2020/03/09/varargs/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-03-19T11:55:34.776Z</updated>
    
    <content type="html"><![CDATA[<p>可变参数：是jdk1.5之后出现的新特性</p><ul><li><p>使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</p></li><li><p>使用格式：</p><pre><code>修饰符 返回值类型  方法名(数据类型... 变量名)</code></pre></li><li><p>可变参数的原理：</p><pre><code>可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数传递的参数个数，可以是0个（不传递），1,2,...多个</code></pre><a id="more"></a></li><li><p>可变参数的注意事项：</p><pre><code>1.一个方法的参数列表，只能有一个可变参数2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</code></pre></li></ul><p>使用示例：</p><pre><code>public static void main(String[] args) {    int i = add(10,11,12);    System.out.println(i);}/*    定义计算（0-n）个整数的和    已知：计算整数的和，数据类型已经确定int    但是参数的个数不确定，不知道要计算几个整数的和，就可以使用可变参数 */public static int add(int... arr){        System.out.println(arr); // [I@74a14482,[代表arr是数组，I代表这个数组是int类型，所以其底层是一个数组        System.out.println(arr.length); // 传递过来的参数个数        int sum = 0;        for (int i : arr) {            sum += i;        }        return sum;    }    // 定义一个方法，计算两个int整数的和    // 可变参数的特殊（终极）写法    public static void method(Object...obj){}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可变参数：是jdk1.5之后出现的新特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;修饰符 返回值类型  方法名(数据类型... 变量名)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可变参数的原理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数
传递的参数个数，可以是0个（不传递），1,2,...多个&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="http://yxym.run/2020/03/08/throwable/"/>
    <id>http://yxym.run/2020/03/08/throwable/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-19T11:59:28.645Z</updated>
    
    <content type="html"><![CDATA[<p>异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p><p>在Java语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常。Java处理异常的方式是中断处理。</p><a id="more"></a><p>异常的根类是<code>java.lang.Throwable</code>，其下有两个子类，<code>java.lang.Error</code>与<code>java.lang.Exception</code></p><p>Throwable体系:</p><ul><li><p>Error:严重错误，无法通过处理的错误只能事先避免。必须修改源代码，程序才能继续执行。</p></li><li><p>Exception:表示异常，异常产生后可以通过代码的方式纠正，使得程序继续运行，是必须要处理的。</p><pre><code>Exception异常主要分为：  编译期异常，进行编译（写代码）java程序出现的异常。RuntimeException：运行期异常，java程序运行过程中出现的问题。</code></pre></li></ul><h4 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h4><p>Java异常处理的五个关键字：<code>try、catch、finally、throw、throws</code></p><p><strong>1、抛出异常throw</strong></p><p>该关键字用于抛出一个指定的异常对象，抛出一个异常具体的操作如下：</p><pre><code>1、创建一个异常对象，封装一些提示信息（信息可以自己编写）2、需要将这个异常对象告知调用者，通过throw关键字即可将这个异常对象传递到调用者处。</code></pre><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><p>使用格式：</p><pre><code>throw new 异常类名(参数);例如：    throw new NullPointerException(&quot;需要访问的arr数组不存在&quot;);</code></pre><p>注意：</p><pre><code>1.throw关键字必须写在方法的内部2.throw关键字后边new的对象必须是Exception或者Exception的子类对象3.throw关键字抛出指定的异常对象，那就必须处理这个异常对象        throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，可以不处理，默认交给JVM（打印异常对象，中断程序）        throw关键字后边创建的是编译异常（写代码的时候报错），必须处理这个异常，要么throws，要么try...catch    </code></pre><h4 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h4><p>对传递过来的参数进行合法性判断，判断是否为null，可以使用Objects中的静态方法：</p><pre><code>public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象是不是null源码：    public static &lt;T&gt; T requireNonNull(T obj){        if (obj == null)            throw new NullPointerException();        return obj;    }</code></pre><p>使用示例：</p><pre><code>public static void main(String[] args) {    int[] arr = null;    getElement(arr,5);}private static int getElement(int[] arr,int index) {    //if (arr == null)    //      throw new NullPointerException(&quot;传递的数组值是null&quot;);    Objects.requireNonNull(arr,&quot;传递的数组值是null&quot;);    if (index &lt; 0||index&gt;=arr.length)        throw new ArrayIndexOutOfBoundsException(&quot;传递的索引超出了数组的使用范围&quot;);    int ele = arr[index];    return ele;}</code></pre><p><strong>2、声明异常throws</strong><br>将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。</p><p>关键字throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常。</p><p>声明异常的格式：</p><pre><code>修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2...{ }</code></pre><p>throws关键字：异常处理的第一种方式，交给别人处理</p><p>作用：</p><ul><li>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</li><li>可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理</li></ul><pre><code>使用格式：在方法声明时使用    修饰符 返回值类型 方法名(参数) throws AAAException,BBBException...{        throw new AAAException(&quot;产生原因&quot;);        throw new BBBException(&quot;产生原因&quot;);     }</code></pre><p>注意：</p><ul><li><p>throws关键字必须写在方法声明处</p></li><li><p>throws关键字后边声明的异常必须是Exception或者是Exception的子类</p></li><li><p>方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常</p><pre><code>如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可</code></pre></li><li><p>调用了一个声明抛出异常的方法，就必须处理得处理声明的异常</p><pre><code>要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM要么使用try...catch自己处理异常</code></pre></li></ul><p>示例代码：</p><pre><code>public static void main(String[] args) throws IOException {    readFile(&quot;&quot;);}/*    FileNotFoundException 是编译异常 */public static void readFile(String fileName) throws IOException {    if (!fileName.equals(&quot;c:\\a.text&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>使用格式：</p><pre><code> try{        可能产生异常的代码    }catch(定义一个异常变量，用来接收try中抛出的异常对象){        异常的处理逻辑，异常对象之后，怎么处理异常对象        一般在工作中，会把异常的信息记录到一个日志中    }    ...    catch(异常类名 变量名){}</code></pre><p>注意：</p><ul><li>try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象</li><li>如果try中产生了异常，那么就会执行catch中异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try…catch之后的代码</li><li>如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try…catch之后的代码</li></ul><p>示例代码：</p><pre><code>public static void main(String[] args) {    try {        readFile(&quot;d:\\a.tx&quot;);    } catch (IOException e) {        System.out.println(&quot;文件的后缀不是.txt&quot;);    }    System.out.println(&quot;后续代码&quot;);}public static void readFile(String fileName) throws IOException {    if (!fileName.endsWith(&quot;.txt&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="Throwable的三个异常处理的方法"><a href="#Throwable的三个异常处理的方法" class="headerlink" title="Throwable的三个异常处理的方法"></a>Throwable的三个异常处理的方法</h4><p>1.<code>String getMessage()</code>:返回此throwable的简短描述</p><p>2.String toString() : 返回此throwable的详细消息字符串</p><p>3.printStackTrace()</p><pre><code>public static void main(String[] args) {    try {        readFile(&quot;d:\\a.tx&quot;);    } catch (IOException e) {        System.out.println(e.getMessage());        /*            传递的文件路径不是c:\a.text         */        //System.out.println(e.toString()); //重写了Object类的toString方法        //System.out.println(e);        /*            java.io.FileNotFoundException: 传递的文件路径不是c:\a.text         */        //e.printStackTrace();        /*        java.io.FileNotFoundException: 传递的文件路径不是c:\a.text            at Throwable.Demo03TryCatch.readFile(Demo03TryCatch.java:40)            at Throwable.Demo03TryCatch.main(Demo03TryCatch.java:26)         */    }    System.out.println(&quot;后续代码&quot;);}public static void readFile(String fileName) throws IOException {    if (!fileName.endsWith(&quot;.txt&quot;)){        throw new FileNotFoundException(&quot;传递的文件路径不是c:\\a.text&quot;);    }    System.out.println(&quot;路径没有问题&quot;);}</code></pre><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>有些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><pre><code>try...catch...finally</code></pre><p>注意：</p><p>1.finally不能单独使用;</p><p>2.finally一般用于资源释放，无论程序是否出现异常，最后都要资源释放。</p><h4 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h4><ul><li>多个异常使用捕获该如何处理呢？</li></ul><p>1.多个异常分别处理</p><pre><code>try{    ...}catch{    ...}try{    ...}catch{    ...}try{    ...}catch{    ...}</code></pre><p>2.多个异常一次捕获、多次处理</p><pre><code>try{    ...}catch(){    ...}catch(){    ...}...</code></pre><p>一个try多个catch注意事项：</p><pre><code>try中如果出现了异常对象，会把异常对象抛出给catch处理，抛出的异常对象，会从上到下依次赋值给catch中定义的异常变量。catch里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上边，否则就会报错</code></pre><p>3.多个异常一次捕获一次处理</p><pre><code>try{    ...}catch(){    ...}try中含有多个异常，在catch可以一次性捕获try中的多个异常，在catch中的异常对象变量要能同时接收多个异常对象</code></pre><ul><li>运行时异常被抛出可以不处理，即不捕获也不声明抛出。默认会给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再来继续执行程序。</li><li>如果finally中有return语句，永远返回finally中的结果，避免该情况。</li><li>如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</li><li>父类方法没有抛出异常，子类重写父类方法时也不可以抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li><li>在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。&lt;/p&gt;
&lt;p&gt;在Java语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常。Java处理异常的方式是中断处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义异常</title>
    <link href="http://yxym.run/2020/03/08/ownDefineException/"/>
    <id>http://yxym.run/2020/03/08/ownDefineException/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2020-03-19T11:54:37.042Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，根据自己业务的异常情况来定义异常类。</p><p>异常类如何定义：</p><ul><li><p>自定义一个编译期异常：自定义类并继承于<code>java.lang.Exception</code></p></li><li><p>自定义一个运行期异常：自定义类并继承于<code>java.lang.RuntimeException</code></p><a id="more"></a><p>格式：</p><p>   public class XXXException extends Exception | RuntimeException{</p><pre><code>添加一个空参数的构造器添加一个带异常信息的构造方法</code></pre><p>   }<br>注意：</p><p>   1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类<br>   2.自定义异常类，必须得继承Exception或者RuntimeException</p><pre><code>继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</code></pre></li></ul><h4 id="自定义异常类练习："><a href="#自定义异常类练习：" class="headerlink" title="自定义异常类练习："></a>自定义异常类练习：</h4><p>1.先定义一个异常类：</p><pre><code>public class RegisterException extends Exception{    public RegisterException() {        super();    }    // 查看源码发现，所有的异常类都会有一个带异常信息的构造方法，    // 方法内部会调用父类带异常信息的构造方法，让父类来处理这个异常信息    public RegisterException(String message){        super(message);    }}</code></pre><p>2.调用</p><pre><code>public class Demo04RegisterException {    static String[] usernames = {&quot;张三&quot;};    public static void main(String[] args) throws RegisterException {        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入您要注册的用户名：&quot;);        String username = sc.next();        checkUsername(username);    }    public static void checkUsername(String username) throws RegisterException {        for (String s : usernames) {            if (s.equals(username)){                throw  new RegisterException(&quot;该用户名已经被注册!&quot;);            }        }        System.out.println(&quot;注册成功！&quot;);    }}</code></pre><p>上面的处理异常的方式是抛出，下面采用捕获异常的方式来处理异常</p><pre><code>public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    System.out.println(&quot;请输入您要注册的用户名：&quot;);    String username = sc.next();    checkUsername(username);}public static void checkUsername(String username){    for (String s : usernames) {        if (s.equals(username)){            try {                throw  new RegisterException(&quot;该用户名已经被注册!&quot;);            } catch (RegisterException e) {                e.printStackTrace();                return; //结束方法，为了避免之后的代码还能被执行            }        }    }    System.out.println(&quot;注册成功！&quot;);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，根据自己业务的异常情况来定义异常类。&lt;/p&gt;
&lt;p&gt;异常类如何定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自定义一个编译期异常：自定义类并继承于&lt;code&gt;java.lang.Exception&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义一个运行期异常：自定义类并继承于&lt;code&gt;java.lang.RuntimeException&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Python的with关键字</title>
    <link href="http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:18.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、上下文管理器的概念"><a href="#1、上下文管理器的概念" class="headerlink" title="1、上下文管理器的概念"></a>1、上下文管理器的概念</h4><p><strong>上下文管理协议（Context Management Protocol）：</strong></p><pre><code>包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 </code></pre><p><strong>上下文管理器（Context Manager）</strong>：</p><pre><code>支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 </code></pre><a id="more"></a><p><strong>运行时上下文（runtime context）：</strong></p><pre><code>由上下文管理器创建，通过上下文管理器的 __enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。 </code></pre><p><strong>上下文表达式（Context Expression）</strong>：</p><pre><code>with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。 </code></pre><p><strong>语句体（with-body）</strong>：</p><pre><code>with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行__exit__() 方法。</code></pre><h4 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h4><p>with表达式其实是try-finally的简写形式。但是又不是全相同。</p><p><strong>格式</strong></p><pre><code>with context [as var]:    pass</code></pre><p>context 是一个表达式，返回的就是支持上下文管理协议的对象，var这个变量用来保存context表达式返回的对象，可以有单个或者多个返回值。</p><pre><code>with open(&apos;test1.txt&apos;) as f:        f.read()</code></pre><p> 表达式open(‘test1.txt’)返回的是一个    _io.TextIOWrapper 类型的对象变量，用f来保存，在with语句块中就可以使用这个变量操作文件。执行with这个结构之后。f会自动关闭，相当于自带了一个finally。</p><p> 注意：with本身并没有异常捕获的功能，但是如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p> 对于自定义的类想要正确使用with关键字，必须实现上述的几个方法才可以：</p><pre><code>class Sample:   def __enter__(self):           pass      def __exit__(self, type, value, trace):           pass</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、上下文管理器的概念&quot;&gt;&lt;a href=&quot;#1、上下文管理器的概念&quot; class=&quot;headerlink&quot; title=&quot;1、上下文管理器的概念&quot;&gt;&lt;/a&gt;1、上下文管理器的概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;上下文管理协议（Context Management Protocol）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;上下文管理器（Context Manager）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python基础知识笔记" scheme="http://yxym.run/categories/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>System类</title>
    <link href="http://yxym.run/2020/03/07/systemClass/"/>
    <id>http://yxym.run/2020/03/07/systemClass/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-19T11:53:35.824Z</updated>
    
    <content type="html"><![CDATA[<p>该类位于java.lang包中，可以直接使用，不用导包。</p><p>System类中提供了大量的静态方法，可以获取与系统相关的信息或系统操作级操作，在System类的<br>API文档中，常用的方法：</p><a id="more"></a><p>1、currentTimeMillis</p><pre><code>public static long currentTimeMillis()</code></pre><p>返回当前时间（以毫秒为单位）。 请注意，虽然返回值的时间单位为毫秒，但该值的粒度取决于底层操作系统，并且可能较大。<br>例如，许多操作系统以几十毫秒为单位测量时间。</p><p>该方法可以用来测试程序的运行效率。</p><p>2、arraycopy</p><pre><code>public static void arraycopy(Object src,                         int srcPos,                         Object dest,                         int destPos,                         int length)</code></pre><p>将指定源数组中的数组从指定位置复制到目标数组的指定位置。</p><p>参数</p><pre><code>src - 源数组。srcPos - 源数组中的起始位置。dest - 目标数组。destPos - 目的地数据中的起始位置。length - 要复制的数组元素的数量。</code></pre><p>代码实例：</p><pre><code>public static void demo02(){    int[] src = {1,2,3,4,5,6};    int[] dest = {6,7,8,9,10,11};    System.out.println(&quot;复制前：&quot;+ Arrays.toString(dest));    System.arraycopy(src,0,dest,0,3);    System.out.println(&quot;复制后：&quot;+Arrays.toString(dest));    /*        复制前：[6, 7, 8, 9, 10, 11]        复制后：[1, 2, 3, 9, 10, 11]    */}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类位于java.lang包中，可以直接使用，不用导包。&lt;/p&gt;
&lt;p&gt;System类中提供了大量的静态方法，可以获取与系统相关的信息或系统操作级操作，在System类的&lt;br&gt;API文档中，常用的方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Idea导入Java se程序无法正常run</title>
    <link href="http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:31.981Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。</p><p>程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。</p><a id="more"></a><ul><li>首先点击Idea左上角的“File”,然后找到“Project Structure ”配置选项</li><li>然后点击“Project setting”选项下的Project选项，设置JDK的版本，并且选择Project language level，因为我的Jdk版本是1.8，所以这里我选的是“Lambdas，type annotation etc”；然后在最下面设置项目的路径，即项目的完整工作空间路径。</li><li>点击“Modules”选项，选择右边方框里的蓝色“Sources”选项，将项目种的src文件设置为源代码文件夹，点击应用，最后点击ok即可运行。</li></ul><h3 id="关于Project-language-level"><a href="#关于Project-language-level" class="headerlink" title="关于Project language level"></a>关于Project language level</h3><p>我们应该知道 Java JDK 在每个新版本都会有其新特性，而新版本一般也会向下兼容旧版本的特性，在IntelliJ IDEA中 对这些 JDK 的新特性是这样介绍的：</p><ul><li>JDK 6 的新特性：@Override in interfaces</li><li>JDK 7 的新特性：Diamonds，ARM，multi-catch etc.</li><li>JDK 8 的新特性：Lambdas，type annotation etc.</li><li>JDK 9 的新特性：Jigsaw project etc.</li></ul><p>其中，当我们使用某一个版本的Jdk的时候，我们只能向下兼容，否则运行程序时是会运行不了的。比如我的Jdk的版本是1.8，那么我只能选择8及以下的language level。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。&lt;/p&gt;
&lt;p&gt;程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践问题总结" scheme="http://yxym.run/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder类</title>
    <link href="http://yxym.run/2020/03/06/stringBuilderClass/"/>
    <id>http://yxym.run/2020/03/06/stringBuilderClass/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-19T11:52:58.073Z</updated>
    
    <content type="html"><![CDATA[<p>又称为字符串缓冲区</p><p>对于String类：</p><ul><li>字符串是常量，它们的值在创建之后不能更改。</li><li>字符串底层是一个被final关键字修饰的数组，不能改变，是一个常量。</li></ul><pre><code>private final byte[] value;  </code></pre><a id="more"></a><p>进行字符串的相加，内存中就会有多个字符串，占用空间多，效率低下。比如：</p><pre><code>String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; = &quot;abc&quot;其运算过程如下：首先: 内存中有三个字符串 &quot;a&quot; &quot;b&quot; &quot;c&quot;然后: &quot;a&quot; + &quot;b&quot; 增加了一个字符串&quot;ab&quot;再然后: &quot;ab&quot; + &quot;c&quot; 增加了一个字符串&quot;abc&quot;此时内存中就会有5个字符串，会造成程序的效率低下，空间浪费</code></pre><p>对于字符串缓冲区，可以提高字符串的操作效率（看成一个长度可以变化的字符串），<br>底层也是一个数组，但是没有被final修饰，可以改变长度。</p><pre><code>byte[] value = new byte[16];</code></pre><p>StringBuilder在内存中始终是一个数组，占用空间少，效率高，初始容量为16字节。</p><p>如果超出了StringBuilder的容量，会自动扩容。    </p><p>StringBuilder类中的append方法：</p><pre><code>public StringBuilder append(...)</code></pre><p>添加任意类型数据的字符串形式并返回当前对象自身。</p><pre><code>public static void main(String[] args) {    StringBuilder bu1 = new StringBuilder();    StringBuilder bu2 = new StringBuilder(&quot;abc&quot;);    System.out.println(bu2);    // 使用append方法往StringBuilder中添加数据    // append方法返回的是this，调用方法的对象bu1,this==bu1    StringBuilder bu3 = bu1.append(&quot;acb&quot;); // 把bu1的地址赋值给了bu3    System.out.println(bu3);    System.out.println(bu1);    System.out.println(bu3==bu1); // 比较的是地址    // 使用append方法无需接收返回值    //append可以添加任意数据类型的数据    /*        链式编程，方法返回值是一个对象，可以继续调用方法    */    bu1.append(&quot;abc&quot;).append(1).append(8.8).append(&apos;中&apos;).append(bu2);    System.out.println(bu3);}</code></pre><p>StringBuilder类中的toString方法：</p><p>StringBuilder -&gt; String:使用StringBuilder的toString方法</p><pre><code>public String toString():将当前StringBuilder对象转换为String对象。</code></pre><p>String -&gt; StringBuilder：使用StringBuilder的构造方法</p><pre><code>String  s = &quot;str&quot;;StringBuilder sbu = new StringBuilder(str);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又称为字符串缓冲区&lt;/p&gt;
&lt;p&gt;对于String类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串是常量，它们的值在创建之后不能更改。&lt;/li&gt;
&lt;li&gt;字符串底层是一个被final关键字修饰的数组，不能改变，是一个常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;private final byte[] value;  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Set接口</title>
    <link href="http://yxym.run/2020/03/05/set/"/>
    <id>http://yxym.run/2020/03/05/set/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2020-03-19T12:02:24.467Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Set</code>接口继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对Collection<br>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。<code>Set</code>接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。</p><a id="more"></a><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址）</p><p>在<code>Object</code>类有一个方法，可以获取对象的哈希值。</p><pre><code>int hashCode() 返回该对象的哈希码值</code></pre><p><code>hashCode</code>方法的源码：</p><pre><code>public native int hashCode();native：代表该方法调用的是本地操作系统的方法</code></pre><p>实例：</p><pre><code>public static void main(String[] args) {    // Person类继承了Object类，所以可以使用Object类的hashCode方法    Person p1 = new Person();    int h1 = p1.hashCode();    System.out.println(h1); // 1956725890    Person p2 = new Person();    int h2 = p2.hashCode();    System.out.println(h2); // 356573597    /*        toString方法的源码：            return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());     */    System.out.println(p1); // Set.Person@74a14482    System.out.println(p2); // Set.Person@1540e19d    /*        对象的地址值用的就是hashcode值，是一个十进制整数     */    System.out.println(p1==p2); // false,即使将hashcode值改成相同的，但是实际的物理地址也不相同    /*        String类的哈希值            String类重写Object类的hashCode方法     */    /*        String类重写的hashCode方法源码：    public int hashCode() {        int h = hash;        if (h == 0 &amp;&amp; value.length &gt; 0) {            char val[] = value;            for (int i = 0; i &lt; value.length; i++) {                h = 31 * h + val[i];            }            hash = h;        }        return h;    }     */    String s1 = new String(&quot;abc&quot;);    String s2 = new String(&quot;abc&quot;);    // s1与s2的哈希值是相同的    System.out.println(s1.hashCode());    System.out.println(s2.hashCode());}</code></pre><h4 id="HashSet集合存储数据的结构"><a href="#HashSet集合存储数据的结构" class="headerlink" title="HashSet集合存储数据的结构"></a>HashSet集合存储数据的结构</h4><p>jdk1.8版本之前：哈希表=数组+链表</p><p>jdk1.8版本之后：<br>    哈希表 = 数组 + 链表  /<br>    哈希表 = 数组 + 红黑树（提高查询的速度）</p><p>哈希表的特点：速度快</p><p>哈希表结构分析：</p><ul><li><p>数组结构：把元素进行了分组，（相同哈希值的元素是一组）</p></li><li><p>链表/红黑树结构把相同哈希值的元素连接到一起</p></li></ul><p>数据存储到集合中的过程：</p><ul><li>先计算元素的哈希值，此哈希值就是该元素在数组中的存储位置</li><li>将元素挂到数组结构中对应的哈希值位置</li><li>如果发生哈希冲突（元素不同但是哈希值相同），将它们挂在相同的数组结构对应的哈希值位置下，形成一个链表结构</li><li>如果链表结构中的元素数量超过了8位，那么就会把链表转为红黑树，目的就是为了提高查询速度</li></ul><h4 id="HashSet存储元素不重复的原理"><a href="#HashSet存储元素不重复的原理" class="headerlink" title="HashSet存储元素不重复的原理"></a>HashSet存储元素不重复的原理</h4><p>Set集合不允许重复存储元素的原理：</p><pre><code>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否重复</code></pre><p>注意，Set集合存储元素不重复的元素：<br>    前提是存储的元素必须重写hashCode方法和equals方法</p><p>具体案例分析：</p><pre><code>public static void main(String[] args) {    //创建HashSet集合对象    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();    String s1 = new String(&quot;abc&quot;);    String s2 = new String(&quot;abc&quot;);    /*        set.add(s1);        1. add方法会调用是s1的hashCode方法，计算字符串“abc”的哈希值，哈希值是一个十进制整数96354        然后会在集合中查找有没有96354这个哈希值的元素，发现没有，就会将s1存储到集合中        set.add(s2);        2. add方法会调用是s2的hashCode方法，计算字符串“abc”的哈希值，哈希值是一个十进制整数96354        然后会在集合中查找有没有96354这个哈希值的元素，发现有（哈希冲突）。s2会调用equals方法和哈希值相同的元素进行比较，        s2.equals(s1)，返回true        两个元素的哈希值相同，equals方法返回true，认定两个元素相同，就不会把s2存储到集合中        set.add(&quot;重地&quot;);        3. add方法会调用是“重地”的hashCode方法，计算字符串“重地”的哈希值，哈希值是一个十进制整数1179395        然后会在集合中查找有没有1179395这个哈希值的元素，发现没有，就会将“重地”存储到集合中        set.add(&quot;通话&quot;);        4. add方法会调用是“通话”的hashCode方法，计算字符串“通话”的哈希值，哈希值是一个十进制整数1179395        然后会在集合中查找有没有1179395这个哈希值的元素，发现有(哈希冲突)，“通话”会调用equals方法和哈希值相同的元素进行比较，        两个元素的哈希值相同，equals方法返回false，认定两个元素不同，就会把该字符串存储到集合     */    set.add(s1);    set.add(s2);    set.add(&quot;重地&quot;);    set.add(&quot;通话&quot;);    set.add(&quot;abc&quot;);    System.out.println(set);}</code></pre><h4 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，必须重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p>实例：</p><p>定义一个Person类，含有属性name和age，同一个人的要求是必须是名字和年龄都相同，将其存放进HashSet必须重写hashcode和equals方法</p><pre><code>public class Person extends Object {    // 重写hashcode方法    private String name;    private int age;    public Person(){}    public Person(String name,int age){        this.name = name;        this.age = age;    }    public int getAge() {        return age;    }public void setAge(int age) {    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}@Overridepublic int hashCode() {    return Objects.hash(name, age);}}</code></pre><p>在主类的主方法中声明一个Person对象，并且进行存入实验：</p><pre><code>public static void main(String[] args) {    // 同名同年龄视为同一个人    // 创建HashSet集合存储Person    HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();    Person p1 = new Person(&quot;xiaomeinv&quot;,18);    Person p2 = new Person(&quot;xiaomeinv&quot;, 18);    Person p3 = new Person(&quot;xiaomeinv&quot;, 19);    set.add(p1);    set.add(p2);    set.add(p3);    System.out.println(set);    System.out.println(p1.hashCode()); // 1583688505    System.out.println(p2.hashCode()); // 1583688505    System.out.println(p1==p2); // false，物理地址不同，所以直接比较也是不同的    System.out.println(p1.equals(p2)); // true}</code></pre><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><pre><code>java.util.LinkedHashSet集合 extends HashSet集合</code></pre><p>LinkedHashSet集合特点：</p><pre><code>底层是一个哈希表（数组+链表/红黑树）+链表：多了一条链表（记录元素的存储顺序），保证元素有序</code></pre><p>实例代码：</p><pre><code>public static void main(String[] args) {    HashSet&lt;Object&gt; set = new HashSet&lt;&gt;();    set.add(&quot;www&quot;);    set.add(&quot;abc&quot;);    set.add(&quot;abc&quot;);    set.add(&quot;itcast&quot;);    System.out.println(set); //无序的，并且不允许重复    LinkedHashSet&lt;Object&gt; linked = new LinkedHashSet&lt;&gt;();    linked.add(&quot;www&quot;);    linked.add(&quot;abc&quot;);    linked.add(&quot;itcast&quot;);    System.out.println(linked); // 有序的，不允许重复}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.Set&lt;/code&gt;接口继承自&lt;code&gt;Collection&lt;/code&gt;接口，它与&lt;code&gt;Collection&lt;/code&gt;接口中的方法基本一致，并没有对Collection&lt;br&gt;接口进行功能上的扩充，只是比&lt;code&gt;Collection&lt;/code&gt;接口更加严格了。&lt;code&gt;Set&lt;/code&gt;接口中的元素无序，并且都会以某种规则保证存入的元素不会出现重复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="http://yxym.run/2020/03/04/objectClass/"/>
    <id>http://yxym.run/2020/03/04/objectClass/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-19T12:04:07.519Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.lang.Object</code>,所有类的父类，它中描述的所有方法子类都可以使用。</p><p>java.lang包中的类可以直接引用，无需导包</p><a id="more"></a><h4 id="Object类的toString方法"><a href="#Object类的toString方法" class="headerlink" title="Object类的toString方法"></a>Object类的toString方法</h4><p>看一个类是否重写了<code>toString</code>，直接打印这个类的对象即可，如果没有重写<code>toString</code>方法，那么打印的是对象的在堆内存中的地址值</p><pre><code>Random a = new Random(); System.out.println(a); //java.util.Random@1540e19dArrayList array = new ArrayList();array.add(1);array.add(2);System.out.println(array); //[1, 2]</code></pre><p>可见Random类并没有重写ToString方法，但是ArrayList类重写了该方法。</p><h4 id="Object类的equals方法"><a href="#Object类的equals方法" class="headerlink" title="Object类的equals方法"></a>Object类的equals方法</h4><p>源码:</p><pre><code>public boolean equals(Object obj) {    return (this == obj);}</code></pre><p>参数：</p><ul><li><p>Object obj：可以传递任意的对象</p></li><li><p>== 比较运算符，返回的是一个布尔值：true，false</p></li><li><p>对于：</p><p>  基本数据类型：比较的是值</p><p>  引用数据类型：比较的是两个对象的地址值</p></li></ul><p>this是谁？</p><p>哪个对象调用的方法，方法中的this就是指的那个对象。</p><p>obj是谁？</p><p>传递过来的参数对象。</p><p>Object类的equals方法，默认比较的是两个对象的地址值，这是没有意义的，所以我们要重写equals方法，<br>比较两个对象的属性。</p><p>但是也会存在一些问题：即隐含着一个多态，多态存在弊端，即无法使用子类特有的内容（属性和方法）</p><p>解决的方案就是：可以使用强制类型转换，将父类引用向下转型成子类引用</p><p>重写某个自定义类的equals方法：</p><pre><code>public boolean equals(Object obj) {    // 增加一个判断，如果传递的参数是本身，则直接返回true，可以提高程序的效率    if (obj == this)        return true;    // 增加一个判断，传递的参数obj如果是null，直接返回false，提高程序的效率    if (obj == null)        return false;    // 增加一个判断，防止出现类型转换异常    if (obj instanceof Person){        //使用向下转型，将obj转换为Person类型        Person p = (Person)obj;        return p.name.equals(this.name) &amp;&amp; this.age==p.age;    }    return false;}</code></pre><p>IDEA重写的自定义类的equals方法：</p><pre><code>public boolean equals(Object o) {    if (this == o) return true;    // getClass() != o.getClass() 使用反射技术，判断o是否是Person类型，等价于obj instanceof Person    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}</code></pre><h4 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h4><p>使用IDEA自动重写的equals代码中，使用到了java.util.Objects类，这个类是JDK7新增加的一个Objects工具类，<br>它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），<br>用于计算对象的hashcode，返回对象的字符串表示形式，比较两个对象。</p><p>在比较两个对象的时候，Object容易抛出空指针异常，但是Objects类中的equals方法优化了这个问题，其源代码如下：</p><pre><code>public static boolean equals(Object a, Object b) {    return (a == b) || (a != null &amp;&amp; a.equals(b));}</code></pre><p>null是不能调用方法的，否则就会抛出空指针异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;,所有类的父类，它中描述的所有方法子类都可以使用。&lt;/p&gt;
&lt;p&gt;java.lang包中的类可以直接引用，无需导包&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Map集合</title>
    <link href="http://yxym.run/2020/03/04/map/"/>
    <id>http://yxym.run/2020/03/04/map/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:44.363Z</updated>
    
    <content type="html"><![CDATA[<p>将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值。</p><pre><code>public interface Map&lt;K,V&gt;</code></pre><p>K代表键的类型，V代表值的类型</p><p>Collection接口定义了单列集合规范，每次存储一个元素。</p><p>Map接口定义了双列集合的规范，每次存储一对儿元素。</p><a id="more"></a><p>Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</p><p>Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过键可以找到对应的值。</p><p>Map集合的特点：</p><ul><li>Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）</li><li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>Map集合中的元素，key是不允许重复的，value是可以重复的</li><li>Map集合中的元素，key和value是一一对应的</li></ul><h4 id="Map常用集合之HashMap-lt-K-V-gt"><a href="#Map常用集合之HashMap-lt-K-V-gt" class="headerlink" title="Map常用集合之HashMap&lt;K,V&gt;"></a>Map常用集合之HashMap&lt;K,V&gt;</h4><p>基于哈希表的Map接口的实现。允许使用null值和null键，此类不保证映射的顺序。</p><p>不同步，多线程。</p><p>HashMap集合的特点：</p><ul><li>HashMap集合底层是哈希表：查询速度特别快。（JDK1.8之后，结构是数组+单向链表/红黑树（链表长度超过8））</li><li>hashMap是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li></ul><h4 id="HashMap常用集合之LinkedHashMap"><a href="#HashMap常用集合之LinkedHashMap" class="headerlink" title="HashMap常用集合之LinkedHashMap"></a>HashMap常用集合之LinkedHashMap</h4><pre><code>java.util.LinkedHashMap&lt;k,v&gt; extends HashMap&lt;k,v&gt;</code></pre><p>LinkedHashMap的特点：</p><ul><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储元素和取出元素的顺序是一致的</li></ul><h4 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h4><p>1.<code>public V put(K key,V value)</code>:把指定的键与指定的值添加到Map集合中</p><ul><li>返回值：v</li><li>存储键值对的时候，key不重复，返回值V是null</li><li>存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值</li></ul><pre><code>private static void show01() {    // 创建Map集合对象，多态    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();    String v1 = map.put(&quot;lichen&quot;, &quot;fanbingbing&quot;);    System.out.println(v1);    String v2 = map.put(&quot;lichen&quot;, &quot;fanb&quot;);    System.out.println(v2);    System.out.println(map); //{lichen=fanb}    map.put(&quot;lengfeng&quot;, &quot;longxiaoyun&quot;);    map.put(&quot;yangguo&quot;,&quot;lalala&quot;);    map.put(&quot;sdhajsd&quot;,&quot;lalala&quot;);    System.out.println(map);}</code></pre><p>2.<code>public V remove(Object key)</code> : 把指定的键对应的键值对元素在Map集合中删除，返回被删除元素的值</p><ul><li>返回值：V</li><li>key存在，V返回被删除的值</li><li>key不存在，V返回null</li></ul><pre><code>private static void show02() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    System.out.println(map);    Integer v1 = map.remove(&quot;zaliying&quot;);    System.out.println(&quot;v1: &quot;+v1); // v1: 168    System.out.println(map);    Integer v2 = map.remove(&quot;zaliying&quot;);    System.out.println(&quot;v2: &quot;+v2); // v1: null    // 移除一个集合中没有的元素，返回值赋值给int类型而不是Integer类型的变量    // 相当于自动拆箱，但是打印输出时，会发生一个空指针异常，复制给其包装类就不会出现这个问题    int v3 = map.remove(&quot;zaliying&quot;);}</code></pre><p>3.<code>public V get(Obejct key)</code>: 根据指定的键，在Map集合中获取对应的值</p><p>返回值：</p><ul><li>key存在，返回对应的value值</li><li>key不存在，返回null</li></ul><pre><code>private static void show03() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    Integer v1 = map.get(&quot;zaliying&quot;);    System.out.println(v1); // 168    Integer v2 = map.get(&quot;dada&quot;);    System.out.println(v2); // null}</code></pre><p>4.<code>boolean containsKey(Object key)</code>: 判断集合中是否包含指定的键</p><ul><li>包含返回true，不包含返回false</li></ul><pre><code>private static void show04() {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    boolean b1 = map.containsKey(&quot;zaliying&quot;);    System.out.println(b1);  // true    boolean sa = map.containsKey(&quot;sa&quot;);    System.out.println(sa); // false}</code></pre><h4 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h4><p>键找值方式：通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><p>1.获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</p><p>2.遍历键的Set集合，得到每一个键</p><p>3.根据键，获取键对应的值</p><p>Map集合的第一种遍历方式：通过键找值的方式</p><pre><code>Map集合中的方法：    Set&lt;K&gt; keySet() 返回此映射中包含的键的Set视图实现步骤：    1.使用Map集合中的方法keySet()，把Map集合所有的key取出来，存储到一个Set集合中    2.遍历Set集合，获取Map集合中的每一个key    3.通过Map集合中的方法get(key),通过key找到value</code></pre><p>具体的代码实例：</p><pre><code>public static void main(String[] args) {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    Set&lt;String&gt; set = map.keySet();    Iterator&lt;String&gt; it = set.iterator();    while (it.hasNext()){        System.out.println(map.get(it.next()));    }    for (String s : set) {        System.out.println(map.get(s));    }}</code></pre><p>遍历set的方式有两种，一种是使用迭代器，另一种是使用增强for循环。</p><h4 id="Entry-lt-K-V-gt-键值对对象"><a href="#Entry-lt-K-V-gt-键值对对象" class="headerlink" title="Entry&lt;K,V&gt;键值对对象"></a>Entry&lt;K,V&gt;键值对对象</h4><p>在Map接口中有一个内部接口Entry</p><p>作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)</p><p>Map集合的第二种遍历方式：使用Entry对象遍历</p><pre><code>Map集合中的方法：    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图实现步骤：    1.使用Map集合中的entrySet()，把Map集合中多个Entry对象取出来，存储到一个Set集合中    2.遍历Set集合，获取每一个Entry对象    3.使用Entry对象中的方法getKey()和getValue()获取键与值</code></pre><p>具体的代码实例：</p><pre><code>public static void main(String[] args) {    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;zaliying&quot;,168);    map.put(&quot;sdada&quot;,178);    map.put(&quot;kakaka&quot;,158);    // Map.Entry 外部类.内部类的方式访问    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();    while (it.hasNext()){        Map.Entry&lt;String, Integer&gt; entry = it.next();        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key+&quot;=&quot;+value);    }    for (Map.Entry&lt;String, Integer&gt; entry : set) {        String key = entry.getKey();        Integer value = entry.getValue();        System.out.println(key+&quot;=&quot;+value);    }}</code></pre><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>此类实现了一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用作键或者值。</p><p>同步的，单线程。</p><pre><code>java.util.Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt;Hashtable：底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快HashMap集合（之前需的所有的集合）：可以存储null值，null键Hashtable集合，不能存储null值，null键1.2版本之后，被更先进的集合取代了Hashtable的子类Properties依然活跃在历史舞台Properties集合是一个唯一和IO流相结合的集合</code></pre><p>如果往Hashtable集合中的键或者值存入null，会发生空指针异常：<code>NullPointerException</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Map&amp;lt;K,V&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;K代表键的类型，V代表值的类型&lt;/p&gt;
&lt;p&gt;Collection接口定义了单列集合规范，每次存储一个元素。&lt;/p&gt;
&lt;p&gt;Map接口定义了双列集合的规范，每次存储一对儿元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>List集合</title>
    <link href="http://yxym.run/2020/03/03/List/"/>
    <id>http://yxym.run/2020/03/03/List/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:24.044Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*    java.util.List接口 extends　Collection接口    List接口的特点：        1.有序的集合，存储元素和取出元素的顺序是一致的        2.有索引，包含了一些带索引的方法        3.允许存储重复的元素    List接口中带索引的方法（特有）：        public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上        public E get(int index)：返回集合中指定位置的元素        public E remove(int index)：移除列表中指定位置的元素，返回的是被移除的元素        public E set(int index,E element)：用指定元素替换集合中指定位置的元素，返回值的更新前的元素    注意：        操作索引时，一定要防止索引越界异常        IndexOutOfBoundException 　索引越界异常，集合会报        ArrayIndexOutOfBoundException　数组索引越界异常        StringIndexOutOfBoundException　字符串索引越界异常 */</code></pre><a id="more"></a><p>实践代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;d&quot;);    list.add(&quot;a&quot;);    System.out.println(list);    // 在指定位置添加指定元素    list.add(3,&quot;fym&quot;);    System.out.println(list);    // 移除指定位置处的元素，返回值是被移除的元素    String re = list.remove(2);    System.out.println(re);    System.out.println(list);    // 用指定元素替换集合中指定的位置的元素，并返回被替换的元素    String setE = list.set(4,&quot;A&quot;);    System.out.println(setE);    System.out.println(list);    // list集合遍历有３种方式    // 使用普通的for循环    for (int i = 0; i &lt; list.size(); i++) {        String s = list.get(i);        System.out.println(s);    }    // 使用迭代器    Iterator&lt;String&gt; it = list.iterator();    while(it.hasNext()){        String s = it.next();        System.out.println(s);    }    // 增强for循环    for (String s : list) {        System.out.println(s);    }}</code></pre><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>它是List接口的大小可变数组的实现，允许包括null在内的所有元素.它是数组结构的，而数组结构的特点就是查询快，增删慢．</p><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小．它总是至少等于列表的大小,随着向<br>ArrayList中不断添加元素，其容量也自动增长</p><p>多线程，不是同步的</p><p>从ArrayList的底层源码来看，如果它要添加一个元素，那么会先创建一个数组，这个新创建的数组的长度是原数组长度加１<br>然后把原数组的数据放到新数组中去．所以ArrayList数组特点是查询快，因为数组里元素的地址都是连续的，<br>但是增删慢，因为每添加或者删除一个元素都得在底层调用一个数组复制的方法，所以此时效率低．</p><p>所以在设计程序时，要根据需求选择是否使用ArrayList,如果查询需求多，则使用ArrayList,如果增删需求多，那么就不建议使用．</p><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>List和Deque接口的双链列表实现，java.util.LinkdeList集合存储结构是链表结构．方便元素添加，删除操作．<br>实现所有可选的list操作，并允许所有元素（包括null）。索引到列表中的操作将从列表的开头或结尾开始遍历列表，以更接近指定索引的位置为准。</p><p>多线程，不是同步的。查询慢，增删快。如果多个线程同时访问一个链表，并且至少有一个线程在结构上修改了链表，则必须在外部进行同步。（结构上修改是指任何增加或删除一个或多个元素的操作，仅仅设置一个元素的值并不是结构的修改）<br>这通常是通过在自然封装列表的某个对象上进行同步来实现的。如果不存在这样的对象，则应使用<code>Collections.synchronizedList</code>方法“包装”列表。最好在创建时完成此操作，以防止意外的不同步访问列表：</p><pre><code>List list = Collections.synchronizedList(new LinkedList(...));</code></pre><p>可以将此集合用作堆栈、队列、双端队列。</p><h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><p>底层也是一个数组结构，Vector类可以实现可增长的对象数组，与普通数组一样，它包含可以使用整数索引进行访问的组件。但是Vector的大小可以根据需要增大或者缩小，以适应创建<br>Vector后进行添加或者移除项的操作。</p><p>它是同步的。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;/*
    java.util.List接口 extends　Collection接口
    List接口的特点：
        1.有序的集合，存储元素和取出元素的顺序是一致的
        2.有索引，包含了一些带索引的方法
        3.允许存储重复的元素
    List接口中带索引的方法（特有）：
        public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上
        public E get(int index)：返回集合中指定位置的元素
        public E remove(int index)：移除列表中指定位置的元素，返回的是被移除的元素
        public E set(int index,E element)：用指定元素替换集合中指定位置的元素，返回值的更新前的元素
    注意：
        操作索引时，一定要防止索引越界异常
        IndexOutOfBoundException 　索引越界异常，集合会报
        ArrayIndexOutOfBoundException　数组索引越界异常
        StringIndexOutOfBoundException　字符串索引越界异常
 */&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Iterator</title>
    <link href="http://yxym.run/2020/03/03/IteratorClass/"/>
    <id>http://yxym.run/2020/03/03/IteratorClass/</id>
    <published>2020-03-02T16:00:00.000Z</published>
    <updated>2020-03-19T12:01:10.273Z</updated>
    
    <content type="html"><![CDATA[<p>迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断;<br>如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><a id="more"></a><p>Iterator接口的常用方法：</p><pre><code>boolean hasNext() 如果仍有元素可以迭代，则返回 true    判断集合中还有没有下一个元素，有就fanhuitrue没有就返回falseE next() 返回迭代的下一个元素    取出集合中的下一个元素</code></pre><p>Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方式比较特殊<br>Collention接口中有一个方法，叫iterator(),这个方法返回的就是迭代器的实现类对象。</p><pre><code>Iterator&lt;E&gt; iterator() 返回在此collection的元素上进行迭代的迭代器</code></pre><p><strong>迭代器的使用步骤：</strong></p><p>1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</p><p>2、使用Iterator接口中的方法hasNext判断还有没有下一个元素</p><p>3、使用Iterator接口中的方法next取出集合中的下一个元素</p><p>实现代码：</p><pre><code>public static void main(String[] args) {    Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();    coll.add(&quot;asd&quot;);    coll.add(&quot;qwe&quot;);    coll.add(&quot;csc&quot;);    /*        1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）        注意：Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型     */    // coll.iterator() 获取迭代器的实现类对象，并且会把指针（索引）指向集合的-1索引    Iterator&lt;String&gt; it = coll.iterator();    // hasNext() 判断集合中还有没有下一个元素    while (it.hasNext()){        // next()方法做了两件事情，第一件是取出下一个元素，第二件是把指针向后移动一位        System.out.println(it.next());    }}</code></pre><h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><p>增强for循环（for-each循环）是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合。它的内部原理其实是一个Iterator迭代器，所以在遍历的过程中，<br>不能对集合中的元素进行增删操作。</p><pre><code>public interface Iterable&lt;T&gt;</code></pre><p>实现这个接口允许对象成为“foreach”语句的目标。</p><pre><code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code></pre><p>所有的单列集合都可以使用增强for</p><p>增强for循环：用来遍历集合和数组</p><p>格式：</p><pre><code>for(集合/数组的数据类型 变量名 ： 集合名/数组名){    sout(变量名);}</code></pre><p>增强for循环必须有被遍历的目标，目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断;&lt;br&gt;如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap存储自定义类型键值</title>
    <link href="http://yxym.run/2020/03/02/HashMap/"/>
    <id>http://yxym.run/2020/03/02/HashMap/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:56.218Z</updated>
    
    <content type="html"><![CDATA[<p>Map集合保证key是唯一的：</p><pre><code>如果自定义类型作为key，必须重写hashCode方法和equals方法，以保证key唯一</code></pre><a id="more"></a><p>实践：</p><p>1.先定义一个自定义类Person</p><pre><code>public class Person {    private String name;    private int age;public Person() {}public Person(String name, int age) {    this.name = name;    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Person person = (Person) o;    return age == person.age &amp;&amp;            Objects.equals(name, person.name);}@Overridepublic int hashCode() {    return Objects.hash(name, age);}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}}</code></pre><p>2.分别将String类和Person作为Map集合的key的类型</p><pre><code>public static void main(String[] args) {    show02();}/*    HashMap存储自定义类型键值    key:Person类型        Person类必须重写hashCode方法和equals方法，可以保证key唯一    value:Person类型        value可以重复(同名同年龄的人视为同一个) */private static void show02() {    HashMap&lt;Person, String&gt; map = new HashMap&lt;&gt;();    map.put(new Person(&quot;nvwang&quot;,18),&quot;yingguo&quot;);    map.put(new Person(&quot;qinshihuang&quot;,18),&quot;taiguo&quot;);    map.put(new Person(&quot;pujing&quot;,30),&quot;eluosi&quot;);    map.put(new Person(&quot;nvwang&quot;,18),&quot;maoliqiusi&quot;);    Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();    for (Map.Entry&lt;Person, String&gt; entry : set) {        Person key = entry.getKey();        String value = entry.getValue();        System.out.println(key+&quot;---&gt;&quot;+value);    }}/*    HashMap存储自定义类型键值    key：String类型        String类重写hashCode方法和equals方法，可以保证key唯一    value：Person类型        value可以重复（同名同年龄的人视为同一个） */private static void show01() {    HashMap&lt;String, Person&gt; map = new HashMap&lt;&gt;();    map.put(&quot;beijing&quot;,new Person(&quot;zhangsan&quot;,18));    map.put(&quot;shanghai&quot;,new Person(&quot;lisi&quot;,19));    map.put(&quot;guangzhou&quot;,new Person(&quot;wangwu&quot;,20));    map.put(&quot;beijing&quot;,new Person(&quot;zhaoliu&quot;,18));    Set&lt;String&gt; set = map.keySet();    for (String key : set) {        Person value = map.get(key);        System.out.println(key+&quot;---&gt;&quot;+value);    }}</code></pre><h4 id="LinkedHashMap-lt-K-V-gt"><a href="#LinkedHashMap-lt-K-V-gt" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h4><p>Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，<br>该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</p><pre><code>LinkedHashMap&lt;String, String&gt; linked = new LinkedHashMap&lt;&gt;();linked.put(&quot;a&quot;,&quot;a&quot;);linked.put(&quot;c&quot;,&quot;c&quot;);linked.put(&quot;d&quot;,&quot;d&quot;);linked.put(&quot;b&quot;,&quot;b&quot;);System.out.println(linked);//key不允许重复，有序// {a=a, c=c, d=d, b=b}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map集合保证key是唯一的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果自定义类型作为key，必须重写hashCode方法和equals方法，以保证key唯一&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://yxym.run/2020/03/02/Generics/"/>
    <id>http://yxym.run/2020/03/02/Generics/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道集合是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。<br>当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><a id="more"></a><p>泛型：是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。<br>泛型也可以看成是一个变量，用来接收数据类型。 </p><pre><code>E e:Element 元素T t:Type 类型</code></pre><p>E：未知的类型</p><p>集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型</p><p>比如ArrayList集合：</p><pre><code>public class ArrayList&lt;E&gt;{    public boolean add(E e){}    public E get(int index){}        ...}</code></pre><p>创建集合对象的时候，就会确定泛型的数据类型</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></pre><p>会把数据类型作为参数传递，把String赋值给E</p><pre><code>public class ArrayList&lt;String&gt;{     public boolean add(String e){}     public String get(int index){}            ...}</code></pre><h4 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h4><pre><code>public static void main(String[] args) {       show02();   }   /*       创建集合对象，使用泛型       好处：           1.避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型           2.把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）       弊端：           泛型是什么类型，只能存储什么类型的数据    */private static void show02() {   ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();   list.add(&quot;abc&quot;);   Iterator&lt;String&gt; it = list.iterator();   while(it.hasNext()){       String s = it.next();       System.out.println(s + &quot;-&gt;&quot; +s.length());   }}   /*       创建集合对象，不使用泛型       好处：           集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据       弊端：           不安全，会引发异常   */private static void show01() {   ArrayList list = new ArrayList();   list.add(&quot;abc&quot;);   list.add(1);   Iterator it = list.iterator();   while(it.hasNext()){   // 取出元素也是Object类型       Object obj = it.next();       System.out.println(obj);   // 想要使用String类特有的方法，length获取字符串长度，不能使用，       // 多态 Object obj = “abc,多态的弊端，父类引用不能调用子类特有的方法   } }</code></pre><h4 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h4><p>定义格式：</p><pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; {}</code></pre><p>示例代码如下：</p><p>定义泛型类：</p><pre><code>/*    定义一个含有泛型的类，模拟ArrayList集合    泛型是一个未知的数据类型，当我们不确定什么数据类型的时候，可以使用泛型    泛型可以接收任意的数据类型，可以使用Integer、String....    创建对象的时候确定泛型的数据类型 */public class GenericClass&lt;E&gt; {    private E name;    public E getName() {        return name;    }    public void setName(E name) {        this.name = name;    }}</code></pre><p>使用：</p><pre><code>public class Demo02Generics {    public static void main(String[] args) {        GenericClass gc = new GenericClass();        gc.setName(&quot;只能是字符串&quot;);        Object obj = gc.getName();        System.out.println(obj);    GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;();    gc2.setName(1);    Integer name = gc2.getName();    System.out.println(name);    GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;();    gc3.setName(&quot;xiaoming&quot;);    String name1 = gc3.getName();    System.out.println(name1);}}</code></pre><h4 id="定义和使用含有泛型的方法"><a href="#定义和使用含有泛型的方法" class="headerlink" title="定义和使用含有泛型的方法"></a>定义和使用含有泛型的方法</h4><p>定义含有泛型的方法：泛型定义在方法的修饰符和返回类型之间</p><p>格式：</p><pre><code>修饰符 &lt;泛型&gt; 返回值类型 方法名（参数列表（使用泛型））{    方法体;}</code></pre><p>含有泛型的方法，在调用方法的时候确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型。</p><p>实例代码：</p><pre><code>// 想使用泛型，必须先定义再使用// 含有泛型的成员方法public &lt;M&gt; void method01(M m){    System.out.println(m);}// 含有泛型的静态方法public static &lt;M&gt; void method02(M m){    System.out.println(m);}public static void main(String[] args) {    GenericMethod gm = new GenericMethod();    /*        调用含有泛型的方法method01        传递什么类型，泛型就是什么类型     */    gm.method01(10);    gm.method01(&quot;aaa&quot;);    gm.method01(8.8);    gm.method02(&quot;静态方法，不建议创建对象使用&quot;);    // 静态方法，通过类名.方法名（参数）可以直接使用    GenericMethod.method02(&quot;静态方法&quot;);    GenericMethod.method02(1);}</code></pre><h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><p>定义格式：</p><pre><code>修饰符 interface 接口名&lt;代表泛型的变量&gt;{}</code></pre><p>含有泛型的接口的两种使用方式：</p><p>先定义含有泛型接口</p><pre><code>public interface GenericInterface&lt;I&gt; {    abstract void method(I e);}</code></pre><p>第一种使用方式：</p><pre><code>/*    含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型    例如：        public interface Iterator&lt;E&gt; {            E next();            ...        }        Scanner类实现了Interator接口，并指定接口的泛型为String，所以重写的next方法泛型默认就是String        public final class Scanner implements Iterator&lt;String&gt;{            public String next(){}        } */public class GenericInterfaceImpl01 implements GenericInterface&lt;String&gt;{    @Override    public void method(String e) {        System.out.println(e);    }}</code></pre><p>第二种使用方式：</p><pre><code>/*    含有泛型的接口的第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走    就相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型    例如：        public interface List&lt;E&gt;{            boolean add(E e);            E get(int index);        }        public class ArrayList&lt;E&gt; implements List&lt;E&gt;{            public boolean add(E e) {}            public E get(int index) {}        } */public class GenericInterfaceImpl02&lt;I&gt; implements GenericInterface&lt;I&gt;{    @Override    public void method(I e) {        System.out.println(e);    }}</code></pre><p>对以上两种方式进行调用：</p><pre><code>public static void main(String[] args) {    // 含有泛型的接口，第一种使用方法    GenericInterfaceImpl01 gi1 = new GenericInterfaceImpl01();    gi1.method(&quot;adada&quot;);    // 含有泛型的接口，第二种使用方法，创建对象的时候确定泛型的类型    GenericInterfaceImpl02&lt;Object&gt; gi2 = new GenericInterfaceImpl02&lt;&gt;();    gi2.method(8.8);    gi2.method(&quot;asasd&quot;);}</code></pre><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>当使用泛型类或者接口作为方法参数类型时，<strong>传递的数据中</strong>，<strong>泛型类型不确定</strong>，可以通过通配符&lt;？&gt;表示。但是一旦使用泛型的通配符，<br>只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><p>例如，ArrayList类型的变量作为方法参数，其中它传递的数据类型并不确定，那就需要使用通配符，如下：</p><pre><code>/*    泛型通配符：        ？：代表任意的数据类型    使用方式：        不能创建对象使用        只能作为方法的参数使用 */public static void main(String[] args) {        ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();        list01.add(1);        list01.add(2);    ArrayList&lt;Object&gt; list02 = new ArrayList&lt;&gt;();    list02.add(&quot;a&quot;);    list02.add(&quot;b&quot;);    printArray(list01);    printArray(list02);}/*    定义一个方法，能遍历所有类型的ArrayList集合    这时候不知道ArrayList集合使用什么数据类型，可以用泛型的通配符？来接收数据类型    注意：        泛型没有继承概念，即下面的ArrayList&lt;?&gt;中的问号不能用Object代替 */private static void printArray(ArrayList&lt;?&gt; list01) {    Iterator&lt;?&gt; it = list01.iterator();    while (it.hasNext()){        // it.next()方法，取出的元素是Object，可以接收任意的数据类型        Object o = it.next();        System.out.println(o);    }}</code></pre><h4 id="泛型的高级使用–受限泛型"><a href="#泛型的高级使用–受限泛型" class="headerlink" title="泛型的高级使用–受限泛型"></a>泛型的高级使用–受限泛型</h4><pre><code>/*    泛型的上限限定： ？ extends E 　代表使用的泛型只能是Ｅ类型的子类／本身    泛型的下限限定： ？　super E    代表使用的泛型只能是Ｅ类型的父类／本身 */public class Demo04 {    public static void main(String[] args) {        Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();        Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();        Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();        Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();        getElement1(list1);//        getElement1(list2); // 报错//        getElement1(list3);//        getElement1(list4);// 报错////        getElement2(list1);//　报错//        getElement2(list2);// 报错        getElement2(list3);        getElement2(list4);    }    // 泛型的上限：此时的泛型？，必须是Number类型或者Number类型的子类    public static void getElement1(Collection&lt;? extends Number&gt; coll){}    // 泛型的下限：此时的泛型？，必须是Number类型或Number类型的父类    public static void getElement2(Collection&lt;? super Number&gt; coll){}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道集合是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。&lt;br&gt;当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Collections工具类</title>
    <link href="http://yxym.run/2020/03/02/collections/"/>
    <id>http://yxym.run/2020/03/02/collections/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2020-03-19T11:48:12.887Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.Collections 是集合工具类，用来对集合进行操作。</p><p><strong>常用方法：</strong></p><p>1.<code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c,T... elements)</code></p><p>作用：一次性往集合中添加多个元素</p><pre><code>ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();// 一次性往集合中添加多个元素Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);System.out.println(list); // [a, b, c, d, e]</code></pre><p>2.<code>public static void shuffle(List&lt;?&gt; list)</code></p><a id="more"></a><p>作用：打乱集合顺序</p><pre><code>Collections.shuffle(list);System.out.println(list);</code></pre><p>注意：shuffle只能用于list，不能用于set</p><p>3.<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code></p><p>作用：将集合中元素按照<strong>默认规则</strong>排序</p><p>注意：</p><ul><li><p>sort(List<T> list)使用前提：</p><pre><code>被排序的集合里边存储的元素对象，必须实现Comparable，重写接口中的方法compareTo</code></pre></li><li><p>Comparable接口的排序规则：</p><pre><code>自己(this) - 参数 ：升序参数 - 自己 ：降序</code></pre></li></ul><p>实例代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();    list01.add(1);    list01.add(3);    list01.add(2);    System.out.println(list01);    //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序    Collections.sort(list01); // 默认是升序    System.out.println(list01);    ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;();    list02.add(&quot;a&quot;);    list02.add(&quot;c&quot;);    list02.add(&quot;b&quot;);    System.out.println(list02); // [a, c, b]    Collections.sort(list02);    System.out.println(list02); // [a, b, c]    ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;();    list03.add(new Person(&quot;张三&quot;,18));    list03.add(new Person(&quot;李四&quot;,20));    list03.add(new Person(&quot;王五&quot;,15));    System.out.println(list03); //[Person{name=&apos;张三&apos;, age=18}, Person{name=&apos;李四&apos;, age=20}, Person{name=&apos;王五&apos;, age=15}]    // 如果想使用sort方法对存储自定义类型数据的集合进行排序，那么这个自定义类型的类必须实现Comparable接口的compareTo方法    Collections.sort(list03);    System.out.println(list03);    //[Person{name=&apos;李四&apos;, age=20}, Person{name=&apos;张三&apos;, age=18}, Person{name=&apos;王五&apos;, age=15}]}</code></pre><p>其中对于自定义类型Person，存储它的集合要想使用sort方法必须实现Comparable接口的compareTo方法：</p><pre><code>public class Person implements Comparable&lt;Person&gt;{    private String name;    private int age;public Person() {}public Person(String name, int age) {    this.name = name;    this.age = age;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &apos;}&apos;;}// 重写排序的规则@Overridepublic int compareTo(Person o) {        //自定义比较的规则，比较两个人的年龄(this,参数Person)//        return this.getAge() - o.getAge(); // 升序        return o.getAge() - this.getAge(); // 降序    }}</code></pre><p><code>Comparable&lt;Person&gt;</code>表示实现这个接口，进行排序的元素的类型是Person类型。</p><p>4 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt;)</code>:</p><p>将集合中元素按照指定规则排序</p><pre><code>Comparator和Comparable的区别    Comparable:自己(this)和别人(参数)比较，自己需要实现Comparable接口，重写比较的规则    Comparator:相当于找一个第三方的裁判，比较两个元素Comparator的排序规则：    o1 - o2 : 升序    o2 - o1 : 降序</code></pre><p>实例代码：</p><pre><code>public static void main(String[] args) {    ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;();    list01.add(1);    list01.add(3);    list01.add(2);    Collections.sort(list01, new Comparator&lt;Integer&gt;() {        // 重写比较的规则        @Override        public int compare(Integer o1, Integer o2) {            //return o1 - o2;//升序            return o2 - o1; //降序        }    });    System.out.println(list01);    ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;();    list02.add(new Student(&quot;lalal&quot;,19));    list02.add(new Student(&quot;dddd&quot;,20));    list02.add(new Student(&quot;kkaka&quot;,30));    list02.add(new Student(&quot;kkaka&quot;,20));//  Collections.sort(list02, new Comparator&lt;Student&gt;() {//  @Override//  public int compare(Student o1, Student o2) {//       return o1.getAge() - o2.getAge(); // 按照年龄升序排序////     return o2.getAge() - o1.getAge(); // 按照年龄降序排序//   }//  });    Collections.sort(list02, new Comparator&lt;Student&gt;() {    @Override    public int compare(Student o1, Student o2) {          int res =  o1.getAge() - o2.getAge(); // 按照年龄升序排序           // 如果年龄相同，则按照名字首字母进行排序           if (res == 0){               res = o1.getName().charAt(0) - o2.getName().charAt(0);            }           return res;      }    });    System.out.println(list02);    // [Student{name=&apos;lalal&apos;, age=19}, Student{name=&apos;dddd&apos;, age=20}, Student{name=&apos;kkaka&apos;, age=20}, Student{name=&apos;kkaka&apos;, age=30}]    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.Collections 是集合工具类，用来对集合进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;public static &amp;lt;T&amp;gt; boolean addAll(Collection&amp;lt;T&amp;gt; c,T... elements)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;作用：一次性往集合中添加多个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
// 一次性往集合中添加多个元素
Collections.addAll(list,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;);
System.out.println(list); // [a, b, c, d, e]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.&lt;code&gt;public static void shuffle(List&amp;lt;?&amp;gt; list)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>包装类</title>
    <link href="http://yxym.run/2020/03/01/baoZhuangClass/"/>
    <id>http://yxym.run/2020/03/01/baoZhuangClass/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-19T11:43:27.504Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据类型使用起来非常方便，但是没有对应的方法来操作这些基本数据类型的数据。<br>可以使用一个类，把基本数据类型装起来，在类中定义一些方法，这个类叫做包装类。<br>我们可以使用类中的方法来操作这些基本类型的数据。</p><p>Java中一共有8种基本数据类型，所以对应的也有8种包装类。包装类位于java.lang包，<br>可以直接使用，无需导包。</p><a id="more"></a><pre><code>byte -&gt; Byteshort -&gt; Shortint -&gt; Integerlong -&gt; Longfloat -&gt; Floatdouble -&gt; Doublechar -&gt; Characterboolean -&gt; Boolean</code></pre><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>基本数据类型与对应的包装类对象之间，来回转换的过程称为“装箱”与“拆箱”：</p><ul><li>装箱：从基本数据类型转换为对应的包装类对象</li><li>拆箱：从包装类对象转换为对应的基本类型</li></ul><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>这里以Integer类型作为例子，说明如何进行装箱操作：</p><p>主要有两大类方法实现装箱操作：</p><p>1、构造方法：</p><ul><li>Integer(int value) 构造一个新分配的Integer对象，它表示指定的int值</li><li>Integer(String s) 构造一个新分配的Integer对象，它表示String参数所指示的int值</li></ul><p>传递的字符串必须是基本数据类型的字符串v，否则会抛出异常，如”100“正确，”a“抛异常。</p><p>2、静态方法</p><ul><li>static Integer valueOf(int i) 返回一个表示指定的int值的Integer实例</li><li>static Integer valueOf(String s) 返回保存制定的String的值的Integer对象</li></ul><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>这里以Integer类型作为例子，说明如何进行拆箱操作：</p><p>成员方法：</p><pre><code>int intValue() 以int类型返回该Integer值</code></pre><p>示例代码：</p><pre><code>public static void main(String[] args) {    // 装箱    Integer in1 = new Integer(1);    System.out.println(in1); // 重写了toString方法    Integer in2 = new Integer(&quot;22&quot;);    System.out.println(in2);    // 静态方法    Integer in3 = Integer.valueOf(1);    // 拆箱    int a = in2.intValue();}</code></pre><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>基本数据类型的数据和包装类之间可以自动的相互转换,这是JDK1.5以后新加的特性.</p><pre><code>public static void main(String[] args) {    /*        自动装箱:直接把int类型的整数赋值给包装类     */    Integer in = 1;    /*        自动拆箱:in是包装类,无法直接参与运算,可以自动转换为基本数据类型,再进行计算        in+2;就相当于in.intValue() + 2 = 3        in = in.intValue() + 2 = 3 又是一个自动装箱     */    in = in + 2;    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    /*    ArrayList集合无法直接存储整数,可以存储Integer包装类     */    list.add(1); // --&gt;自动装箱 list.add(new Integer(1));    int a = list.get(0); // --&gt;自动拆箱 list.get(0).intValue();}</code></pre><h3 id="基本类型与字符串类型之间的相互转换"><a href="#基本类型与字符串类型之间的相互转换" class="headerlink" title="基本类型与字符串类型之间的相互转换"></a>基本类型与字符串类型之间的相互转换</h3><ul><li><p>基本类型 -&gt; 字符串(String)</p><p>1.基本类型的值+””  最简单的方法</p><p>2.包装类的静态方法toString(参数),不是Object类的toString(),二者是重载关系</p><pre><code>static String toString(...)  返回一个表示制定参数的String对象</code></pre><p>3.String类的静态方法valueOf(参数),返回参数的字符串表示形式</p><pre><code>static String valueOf(...)</code></pre><ul><li><p>字符串(String) -&gt; 基本类型</p><p>使用包装类的静态方法parseXXX(“字符串”)</p><p>Integer类: static int parseInt(String s)</p><p>Double类: static double parseDouble(String s)</p></li></ul></li></ul><p>示例代码:</p><pre><code>public static void main(String[] args) {    int i1 = 100;    String s1 = i1+&quot;&quot;;    System.out.println(s1+200);    String s2 = Integer.toString(100);    System.out.println(s2+200);    String s3 = String.valueOf(100);    System.out.println(s3+200);    int i = Integer.parseInt(s1);    System.out.println(i-10);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本数据类型使用起来非常方便，但是没有对应的方法来操作这些基本数据类型的数据。&lt;br&gt;可以使用一个类，把基本数据类型装起来，在类中定义一些方法，这个类叫做包装类。&lt;br&gt;我们可以使用类中的方法来操作这些基本类型的数据。&lt;/p&gt;
&lt;p&gt;Java中一共有8种基本数据类型，所以对应的也有8种包装类。包装类位于java.lang包，&lt;br&gt;可以直接使用，无需导包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Collection集合</title>
    <link href="http://yxym.run/2020/03/01/CollectionClass/"/>
    <id>http://yxym.run/2020/03/01/CollectionClass/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-19T12:00:10.192Z</updated>
    
    <content type="html"><![CDATA[<p>集合:集合是java中提供的一种<strong>容器</strong>,可以用来存储多个数据</p><p>集合与数组的区别:</p><ul><li>数组的长度是固定的,集合的长度是可变的</li><li>数组中存储的是同一类型的元素,可以存储基本数据类型值也可以存储对象.集合存储的都是对象,而且对象的类型可以不一致.<a id="more"></a></li></ul><p><strong>学习集合的目标:</strong></p><p>1、会使用集合存储数据</p><p>2、会遍历集合，把数据取出来</p><p>3、掌握每种集合的特性</p><p><strong>集合框架的学习方式：</strong></p><p>1、学习顶层：学习顶层接口/抽象类中共性的方法，所有子类都可以使用</p><p>2、使用底层：顶层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>定义的是所有单列集合中共性的方法，所有的单列集合都可以使用共性的方法。</p><p>比如没有带索引的方法</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>实现了Collection接口，该接口定义了以下几个性质：</p><p>1、有序的集合（存储和取出元素顺序相同）</p><p>2、允许存储重复的元素</p><p>3、有索引，可以使用普通的for循环遍历。</p><p>实现了该接口的集合有Vector、ArrayList、LinkedList集合。</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>实现了Collection接口，该接口定义了以下几个性质：</p><p>1、不允许存储重复元素</p><p>2、没有索引（不能使用普通的for循环遍历）</p><p>实现了该接口的集合有TreeSet集合、HashSet集合，其中这两个集合是无序的集合（存储和取出元素的顺序有可能不一致）</p><p>LinkedHashSet集合继承了HashSet，它是一个有序的集合。</p><h4 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h4><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可用于操作所有的<br>单列集合。方法如下：</p><pre><code>public static void main(String[] args) {    // 创建集合对象，可以使用多态    Collection&lt;String&gt; coll = new HashSet&lt;&gt;();    System.out.println(coll); // 重写了toString方法 []    /*        public boolean add(E e): 把给定的对象添加到当前集合中        返回值是一个布尔值，一般都返回true，所以可以不用接收    */    boolean b1 = coll.add(&quot;张三&quot;);    System.out.println(coll);    coll.add(&quot;liss&quot;);    coll.add(&quot;liss&quot;);    coll.add(&quot;zhaoliu&quot;);    System.out.println(coll); // [张三, liss, wangwu, zhaoliu]    /*        public boolean remove(E,e):        返回值是一个boolean值，集合中存在元素，删除元素，返回true        集合中不存在元素，删除失败，返回false     */    boolean b2 = coll.remove(&quot;liss&quot;);    System.out.println(&quot;b2:&quot;+b2);    boolean b3 = coll.remove(&quot;aaa&quot;);    System.out.println(&quot;b3:&quot;+b3);    System.out.println(coll); // [张三, wangwu, zhaoliu]    /*        public boolean contains(E e):判断当前集合中是否包含给定的对象        包含返回true        不包含返回false     */    boolean b4 = coll.contains(&quot;wangwu&quot;);    System.out.println(&quot;b4:&quot;+b4); // true    boolean b5 = coll.contains(&quot;ada&quot;);    System.out.println(&quot;b5:&quot;+b5); // false    /*        public boolean isEmpty():判断当前集合是否为空     */    boolean b6 = coll.isEmpty();    System.out.println(&quot;b6:&quot;+b6); //false    /*        public int size():返回集合中元素的个数     */    int size = coll.size();    System.out.println(&quot;size:&quot;+size);    /*    public Object[] toArray():把集合中的元素，存储到数组中     */    Object[] arr = coll.toArray();    for (int i = 0;i&lt;arr.length;i++){        System.out.println(arr[i]);    }    /*        public void clear():清空集合中所有元素，但是不删除集合，集合还存在     */    coll.clear();    System.out.println(coll.isEmpty());}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合:集合是java中提供的一种&lt;strong&gt;容器&lt;/strong&gt;,可以用来存储多个数据&lt;/p&gt;
&lt;p&gt;集合与数组的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组的长度是固定的,集合的长度是可变的&lt;/li&gt;
&lt;li&gt;数组中存储的是同一类型的元素,可以存储基本数据类型值也可以存储对象.集合存储的都是对象,而且对象的类型可以不一致.
    
    </summary>
    
    
      <category term="Java Se学习笔记" scheme="http://yxym.run/categories/Java-Se%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第226题</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:35.389Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>翻转二叉树</p><p>示例：</p><p>输入：</p><pre><code>       4     /   \  2     7 / \   / \1   3 6   9</code></pre><a id="more"></a><p>输出：</p><pre><code>      4    /   \  7     2 / \   / \9   6 3   1</code></pre><p>据说有个很牛逼的大佬曾经去谷歌应聘，结果倒在了这道算法题上，所以看着简单，但还是需要对数据结构这些基础知识拥有足够的重视。</p><p>这个题目看起来是让翻转二叉树，实质上是对二叉树进行遍历，只要能够遍历到结点，就能够实现对该结点的左右子树进行交换，然后要么递归从下往上做要么从上往下依次迭代实现。本文正是借用二叉树的几种遍历算法作为模板进行翻转的。</p><p><strong>解法一：递归翻转</strong></p><pre><code> // 使用递归的方式对二叉树进行翻转public TreeNode invertTree(TreeNode root) {    if (root == null)        return null;    TreeNode lchild = root.left;    TreeNode rchild = root.right;    root.left = invertTree(rchild);    root.right = invertTree(lchild);    return root;}</code></pre><p><strong>解法二：使用层次遍历进行翻转，借用了队列</strong></p><pre><code>// 使用队列对二叉树进行层次遍历的方式进行翻转二叉树public TreeNode invertTree2(TreeNode root) {    if (root == null)        return null;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    queue.add(root);    while(!queue.isEmpty()){        TreeNode cur = queue.poll();        if ((cur.left==null)&amp;&amp;(cur.right==null))            continue;        TreeNode temp = cur.left;        cur.left = cur.right;        cur.right = temp;        if (cur.left!=null)            queue.add(cur.left);        if (cur.right!=null)            queue.add(cur.right);    }    return root;}</code></pre><p><strong>解法三：使用后序遍历进行翻转，借用了栈</strong></p><pre><code> // 使用栈对二叉树进行后序遍历来翻转二叉树public TreeNode invertTree3(TreeNode root) {    if (root == null)        return null;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                TreeNode temp = node.left;                node.left = node.right;                node.right = temp;                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }    return root;}</code></pre><p>  其他的二叉树遍历方法也可以实现对二叉树的翻转，只用对二叉树便利模板程序中访问结点处的程序进行改动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻转二叉树&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       4
     /   \
  2     7
 / \   / \
1   3 6   9&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode算法模板二叉树的遍历</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:22.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><p>二叉树是n个结点的有限集合，其中n&gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。<br>2、二叉树中不存在度大于2的结点。<br>3、即使只有一棵子树，也要区分它是左子树还是右子树。</p><a id="more"></a><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>关于二叉树的遍历方式有很多种，主要有前、中、后、层次遍历等四种方式，在实现时也有递归的方式和非递归的方式。有很多关于二叉树的算法题目都是基于二叉树的遍历进行展开的，因此我想把二叉树的所有遍历方式进行一次全面的总结。</p><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>1、前序遍历，preVisit(root)</p><p>主要过程为以下三步：</p><ul><li>visit(toot)</li><li>preVisit(root.left)</li><li>preVisit(root.right)</li></ul><p>2、中序遍历，midVisit(root)</p><p>主要过程为以下三步：</p><ul><li>midVisit(root.left)</li><li>visit(toot)</li><li>midVisit(root.right)</li></ul><p>3、后序遍历，postVisit(root)</p><p>主要过程为以下三步：</p><ul><li>postVisit(root.left)</li><li>postVisit(root.right)</li><li>visit(toot)</li></ul><p>具体代码如下：</p><pre><code>public void preVisit(TreeNode root){   if (root==null)       return;   System.out.println(root.val);   preVisit(root.left);   preVisit(root.right);}public void midVisit(TreeNode root){   if (root==null)       return;   midVisit(root.left);   System.out.println(root.val);   midVisit(root.right);}public void postVisit(TreeNode root){   if (root==null)       return;   postVisit(root.left);   postVisit(root.right);   System.out.println(root.val);}</code></pre><h4 id="非递归，借助于栈和队列"><a href="#非递归，借助于栈和队列" class="headerlink" title="非递归，借助于栈和队列"></a>非递归，借助于栈和队列</h4><p>1、前序、中序非递归遍历<br>二者过程类似，只是访问结点的顺序有所差别，具体的代码如下：</p><pre><code>public void preVisitWithStack(TreeNode root){    if (root==null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()) {        while (node!=null){            System.out.println(node.val);            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            node = node.right;        }    }}public void midVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()){        while (node!=null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            System.out.println(node.val);            node = node.right;        }    }}</code></pre><p>都是使用两层的while循环，外层循环用于保证栈不是空的或者结点存在，然后内存循环用于一直迭代遍历结点的左子树，直到没有做子树为止，然后方向转向右子树。差别只在于访问元素位置的因为前序和中序的原因而不同。</p><p>2、后序遍历<br>后序遍历也是借助于栈，但是有一个需要注意的是还需要借助一个lastvisit指针，由于后序遍历是先左子树后右子树最后父亲结点，而程序在遍历二叉树的过程中在其左子树已经被访问过以后，什么情况下，才能访问父亲结点？一个就是该父亲结点没有右子树，所以可以直接访问父亲结点，另外一个就是该父亲结点的右子树已经被访问过了，接下来该父亲结点访问了。所以为了记录父亲结点的右子树是否被访问过，就定义了这个指针，这是很关键的一步。</p><pre><code> public void postVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    // 此处设置lastVisit指针是为了确认在某个父亲结点拥有右结点的情况下，这个右结点    // 是否已经被访问过了，如果访问了当前结点就要出栈被访问，因为后序遍历的顺序就是左右中    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                System.out.println(node.val);                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }}</code></pre><p>   3、层次遍历<br>   根据层次遍历一层一层访问的特点，可以借助队列结构来完成层次遍历。具体代码实现如下：</p><pre><code>public void levelVisit(TreeNode root){    if (root == null)        return;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.add(root);    while(!queue.isEmpty()){        root = queue.poll();        System.out.println(root.val);        if (root.left != null)            queue.add(root.left);        if (root.right != null)            queue.add(root.right);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的概念&quot;&gt;&lt;a href=&quot;#二叉树的概念&quot; class=&quot;headerlink&quot; title=&quot;二叉树的概念&quot;&gt;&lt;/a&gt;二叉树的概念&lt;/h3&gt;&lt;p&gt;二叉树是n个结点的有限集合，其中n&amp;gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。&lt;/p&gt;
&lt;h3 id=&quot;性质：&quot;&gt;&lt;a href=&quot;#性质：&quot; class=&quot;headerlink&quot; title=&quot;性质：&quot;&gt;&lt;/a&gt;性质：&lt;/h3&gt;&lt;p&gt;1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。&lt;br&gt;2、二叉树中不存在度大于2的结点。&lt;br&gt;3、即使只有一棵子树，也要区分它是左子树还是右子树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第219题</title>
    <link href="http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2020-03-09T14:47:33.131Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p><strong>示例 1:</strong></p><p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p><a id="more"></a><p><strong>示例 2:</strong></p><p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p><p><strong>分析：</strong><br>从这个题目看来，并没有要求有空间复杂度的限制，因此我们可以借助于哈希表来完成以上的操作。</p><p><strong>做法1：</strong><br>其中我的做法是借助于HashMap，以元素值作为哈希表的key值，元素的索引值作为哈希表的value值，利用for循环遍历数组，如果当前key在hashmap中没有值则存入hashmap，如果当前key在hashmap中有值则取出其value，这个value就是数组元素的索引值，然后对当前for循环的游标变量与取出来的value值进行判断，具体的代码实现如下所示：</p><pre><code> public boolean containsNearbyDuplicate(int[] nums, int k) {    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    int flag = 0;    for(int i = 0;i &lt; nums.length;i++){        if (map.get(nums[i])==null){            map.put(nums[i],i);        }else {            int j = map.get(nums[i]);            if (( j!=i)&amp;&amp;(Math.abs(i-j) &lt;= k)){                flag = 1;            }else {                map.put(nums[i],i);            }        }    }    if (flag==1)        return true;    return false;}</code></pre><p>   但是我的这个做法，无论从程序运行时间还是内存消耗，都不是很好，因此我查看了一些性能比较好的程序，在此学习记录。</p><p>**   做法2：**<br>  思路：用散列表来维护这个kk大小的滑动窗口。<br>  这个做法借助了hashset，通过设立这个集合，确保这个集合中的元素数量不大于k，一旦大于k就要删去最先存入集合的元素，其中如果在for循环结束前，要存入的元素在集合中存在了，则说明题目中所要求的那两个相等的元素找到了，如果在for循环结束以后还是没有返回true，则说明没有符合条件的元素则返回false。这个程序的作者设计的很巧妙，相比于我的程序，运行速度要快的多。<br>  具体的代码如下：</p><pre><code>public boolean containsNearbyDuplicate2(int[] nums, int k) {    if(k==35000) return false;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int i = 0; i &lt; nums.length; ++i) {        if (set.contains(nums[i])) return true;        set.add(nums[i]);        if (set.size() &gt; k) {            set.remove(nums[i - k]);        }    }    return false;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: nums = [1,0,1,1], k = 1&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第190题</title>
    <link href="http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:27:08.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</code></pre><a id="more"></a><p><strong>注意：</strong><br>我用的是Java语言，但是在Java语言中，没有无符号整型，在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响我们的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p><strong>解题思路：</strong></p><p>将一个32位的整数的二进制形式进行翻转，对于二进制形式的数，可以考虑采用位运算。并且需要注意的是有一点是对于任意的整数n，对它与1进行进行“与”运算，最终得到的结果都取决于该数字最后一位，如果是1，则说明n的二进制形式中，最后一位是1；如果是0，则说明n的二进制形式中，最后一位是0。通过这种方式，可以逐个的提取n的二进制位中的每一位数字。基于以上思路，有以下两种翻转方式：</p><ol><li>从左向右移位置，提取最后一位，从右向左移位，或运算</li></ol><p>取一个游标变量i，其取值从31到0，表示先提取n的二进制形式的最后一位，然后将倒数第二位右移到最后一位，提取；继续将倒数第三位右移到最后一位，，以此类推。代码如下：</p><pre><code>（n &gt;&gt; (31-i)）&amp; 1</code></pre><p>取完最后一位的值以后，将其进行左移，左移的位数整数前边右移时的游标变量i的值，根据对称的性质可知，翻转正是将第31位移到第0位，第30位移到第1位；代码如下：</p><pre><code>（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>再声明一个结果变量result，初始值为0，它将与每次左移后的结果进行“或”运算，经过31次或运算之后，它就是最终的翻转的结果值。</p><pre><code>result |（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>完整的代码实现如下：</p><pre><code>public int reverseBits(int n) {       int ret = 0;    for (int i =31;i&gt;=0;i--){       ret = ret | (((n&gt;&gt;(31-i))&amp;1) &lt;&lt; i);   }   return ret; }</code></pre><p>  ii. 第二种方式，是我在题解中看到的一个内存空间消耗较少的程序，因为上一个方法虽然运行时间特别快，超过了100%的人，但是内存消耗却只超过了5%的人的程序。在这个方式中，也是声明了一个结果变量ret，但是它并没有先右移，然后提取，再左移，最后或运算；而是也对res变量进行移位操作，即先将res左移，提取完原数的最后一位之后与res或运算，然后直接将就地对n右移，完整的代码如下：</p><pre><code>public int reverseBits2(int n){    int res = 0;    int count = 0;    while (count &lt; 32) {        res &lt;&lt;= 1;        res |= (n &amp; 1);        n &gt;&gt;= 1;        count ++;    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>GO语言学习之函数</title>
    <link href="http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/</id>
    <published>2020-02-26T14:41:00.000Z</published>
    <updated>2020-02-26T14:43:50.613Z</updated>
    
    <content type="html"><![CDATA[<p>在go语言中,函数存在以下几个与其他编程语言显著不同的地方:<br>1、函数可以有多个返回值<br>2、所有的参数传递都是值传递的方式<br>3、函数可以作为变量的值<br>4、函数可以作为参数和返回值</p><p>本文主要针对第四点来进行笔记记录</p><a id="more"></a><h3 id="函数可以作为参数和返回值"><a href="#函数可以作为参数和返回值" class="headerlink" title="函数可以作为参数和返回值"></a>函数可以作为参数和返回值</h3><p>首先定义一个函数timeSpent，它的作用类似于面向对象编程中的装饰者模式，对一个函数“装饰”上记录运行时间的功能，以此来衡量一个函数的运行时间，其中被衡量的函数是作为参数传入到timeSpent中去的，代码如下：</p><pre><code>func timeSpent(inner func(op int) int) func (opt int) int{return func(n int) int {    start := time.Now()    ret := inner(n)    fmt.Println(&quot;time spent&quot;,time.Since(start).Seconds())    return ret}}</code></pre><p>其中，传入的参数是一个函数类型，该参数函数的返回值是一个整型，timeSpent的返回值类型也为一个函数类型。</p><p>然后定义一个用来测试的函数：</p><pre><code>func slowFun(op int) int{    time.Sleep(time.Second*1)    return  op}</code></pre><p>该函数并没有多余的功能，只是将传入的参数再次原值返回，期间函数会休眠一段时间。</p><p>调用执行：</p><pre><code>func TestFn(t *testing.T)  {tsSF := timeSpent(slowFun)t.Log(tsSF(10))}</code></pre><p>程序的执行过程如下：<br>1、首先将slowFun函数作为参数传入到timeSpent中去，然后将其装饰为一个具有记录运行时间的函数后，返回一个被装饰的函数，return后方的函数内部逻辑并不执行，只是将原有的函数进行装饰；<br>2、tsSF被赋予一个函数，该函数的具体业务逻辑等同于timeSpent函数中return语句后方的函数；<br>3、调用执行tsSF，传入参数10，执行逻辑见timeSpent中return语句后方的部分，打印输出10。</p><p>以上就是go语言中函数作为参数和返回值的实例，此种编程模式也成为函数式编程，可以在《计算机程序的构造与解释》这本书中了解更多更深入的关于函数式编程的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在go语言中,函数存在以下几个与其他编程语言显著不同的地方:&lt;br&gt;1、函数可以有多个返回值&lt;br&gt;2、所有的参数传递都是值传递的方式&lt;br&gt;3、函数可以作为变量的值&lt;br&gt;4、函数可以作为参数和返回值&lt;/p&gt;
&lt;p&gt;本文主要针对第四点来进行笔记记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go语言学习笔记" scheme="http://yxym.run/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>大学回忆一</title>
    <link href="http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2020-02-26T15:18:24.181Z</updated>
    
    <content type="html"><![CDATA[<p>时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。<a id="more"></a>回望本科四年，心中却没有泛起丝毫波澜，或许是因为大学生活过的平凡无奇，或许是因为年过20早已没有了十几岁的热情与心气。</p><p>本科四年，是我特别想要证明自己的四年，或许是因为对高考结果的不满，或许是因为对自己的不甘心，总之在踏入校园的那一刻起，我发誓我一定要做一个追逐优秀的人，我没有对任何说，因为我也不认识任何人，哈哈哈。可就是这股力量一直在驱动着我前进，我努力地学习每一门课程，以使自己对所学的课程都能有一个深刻的认识与理解而不是简单地只为拿一个不错的期末分数，诚然，我这么学，每一门分数也都是很理想的，当然，英语除外，其实我当年英语也他挺好的，只是后来碰到了一位经常把我讲睡着的英语老师，然后就对英语彻底丧失了兴趣，以至于英语成绩一直不愠不火，哈哈哈。</p><p>我大学是软件工程，其实我在上大学之前对计算机的认识只有能打游戏和能做PPT这两种认识，更别说那些什么CPU、GPU、内存等什么专业术语，一开学的时候我挺自卑的，因为别人能一起侃侃而谈，我却对此一窍不通，这种感觉严重的刺痛了我，妈的，老子不能服输，因此我一边学习理论知识，一边了解计算机相关的知识，不管是硬件还是软件，只要是和Computer相关，我都会刻意去了解，慢慢滴也对这些知识熟悉了起来。另一个自卑的就是自己的编程能力了，有的同学大一的时候就能参加竞赛拿奖而我还只是一个臭弟弟，没办法，我这个人就是比较的自找没趣，喜欢和比我强的人比，也许是我争强好胜的原因，其实这一点挺不好的，因为容易把自己的心态搞砸了，心态一旦失衡，做什么事都容易翻车。扯远了，继续刚才的话题，为让自己也能编程能力有个大的提高，自己也在寒暑假学习编程语言，练习编程。虽然不能说自己能力提高了很多，但是起码上手的速度快了很多。现在回忆那些生活，突然有些小怀念了，哈哈哈，总之那段生活挺单调的，因为自己没交多少朋友，甚至能连学校有多少好吃的都不知道哈哈哈，因为每天标准的吃米饭套餐，哎，人生苦短，要及时行乐啊，不能苦了自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。
    
    </summary>
    
    
      <category term="活有所思" scheme="http://yxym.run/categories/%E6%B4%BB%E6%9C%89%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
</feed>
