<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有心有梦</title>
  
  <subtitle>YXYM</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yxym.run/"/>
  <updated>2020-03-07T06:48:31.981Z</updated>
  <id>http://yxym.run/</id>
  
  <author>
    <name>疯渔民</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Idea导入Java se程序无法正常run</title>
    <link href="http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yxym.run/2020/03/07/Idea%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8run%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:31.981Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。</p><p>程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。</p><a id="more"></a><ul><li>首先点击Idea左上角的“File”,然后找到“Project Structure ”配置选项</li><li>然后点击“Project setting”选项下的Project选项，设置JDK的版本，并且选择Project language level，因为我的Jdk版本是1.8，所以这里我选的是“Lambdas，type annotation etc”；然后在最下面设置项目的路径，即项目的完整工作空间路径。</li><li>点击“Modules”选项，选择右边方框里的蓝色“Sources”选项，将项目种的src文件设置为源代码文件夹，点击应用，最后点击ok即可运行。</li></ul><h3 id="关于Project-language-level"><a href="#关于Project-language-level" class="headerlink" title="关于Project language level"></a>关于Project language level</h3><p>我们应该知道 Java JDK 在每个新版本都会有其新特性，而新版本一般也会向下兼容旧版本的特性，在IntelliJ IDEA中 对这些 JDK 的新特性是这样介绍的：</p><ul><li>JDK 6 的新特性：@Override in interfaces</li><li>JDK 7 的新特性：Diamonds，ARM，multi-catch etc.</li><li>JDK 8 的新特性：Lambdas，type annotation etc.</li><li>JDK 9 的新特性：Jigsaw project etc.</li></ul><p>其中，当我们使用某一个版本的Jdk的时候，我们只能向下兼容，否则运行程序时是会运行不了的。比如我的Jdk的版本是1.8，那么我只能选择8及以下的language level。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在windows下刷Leetcode，代码都保存在了一个project里面，后来开始经常使用Ubuntu系统，索性把以前的刷题代码拷贝过来，继续写在之前的项目里面。但是当我导入项目之后，Idea并没有不能立即执行程序，需要对项目进行一些配置。&lt;/p&gt;
&lt;p&gt;程序出现的情况时，正常情况下，一个java文件图标显示为是一个蓝色的“c”，但是现在显示的是一个橙色的小时钟的标志，原因是Idea并不能自动识别程序的源代码，我们需要做一些配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践问题总结" scheme="http://yxym.run/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Python的with关键字</title>
    <link href="http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yxym.run/2020/03/07/Python%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-03-07T06:48:18.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、上下文管理器的概念"><a href="#1、上下文管理器的概念" class="headerlink" title="1、上下文管理器的概念"></a>1、上下文管理器的概念</h4><p><strong>上下文管理协议（Context Management Protocol）：</strong></p><pre><code>包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 </code></pre><p><strong>上下文管理器（Context Manager）</strong>：</p><pre><code>支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 </code></pre><a id="more"></a><p><strong>运行时上下文（runtime context）：</strong></p><pre><code>由上下文管理器创建，通过上下文管理器的 __enter__() 和__exit__() 方法实现，__enter__() 方法在语句体执行之前进入运行时上下文，__exit__() 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。 </code></pre><p><strong>上下文表达式（Context Expression）</strong>：</p><pre><code>with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。 </code></pre><p><strong>语句体（with-body）</strong>：</p><pre><code>with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的 __enter__() 方法，执行完语句体之后会执行__exit__() 方法。</code></pre><h4 id="2、with关键字"><a href="#2、with关键字" class="headerlink" title="2、with关键字"></a>2、with关键字</h4><p>with表达式其实是try-finally的简写形式。但是又不是全相同。</p><p><strong>格式</strong></p><pre><code>with context [as var]:    pass</code></pre><p>context 是一个表达式，返回的就是支持上下文管理协议的对象，var这个变量用来保存context表达式返回的对象，可以有单个或者多个返回值。</p><pre><code>with open(&apos;test1.txt&apos;) as f:        f.read()</code></pre><p> 表达式open(‘test1.txt’)返回的是一个    _io.TextIOWrapper 类型的对象变量，用f来保存，在with语句块中就可以使用这个变量操作文件。执行with这个结构之后。f会自动关闭，相当于自带了一个finally。</p><p> 注意：with本身并没有异常捕获的功能，但是如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p> 对于自定义的类想要正确使用with关键字，必须实现上述的几个方法才可以：</p><pre><code>class Sample:   def __enter__(self):           pass      def __exit__(self, type, value, trace):           pass</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1、上下文管理器的概念&quot;&gt;&lt;a href=&quot;#1、上下文管理器的概念&quot; class=&quot;headerlink&quot; title=&quot;1、上下文管理器的概念&quot;&gt;&lt;/a&gt;1、上下文管理器的概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;上下文管理协议（Context Management Protocol）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;包含方法 __enter__() 和 __exit__()，支持该协议的对象要实现这两个方法。 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;上下文管理器（Context Manager）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;支持上下文管理协议的对象，这种对象实现了__enter__() 和 __exit__() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python基础知识笔记" scheme="http://yxym.run/categories/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷提笔记之第226题</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E5%88%B7%E6%8F%90%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC226%E9%A2%98/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:35.389Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>翻转二叉树</p><p>示例：</p><p>输入：</p><pre><code>       4     /   \  2     7 / \   / \1   3 6   9</code></pre><a id="more"></a><p>输出：</p><pre><code>      4    /   \  7     2 / \   / \9   6 3   1</code></pre><p>据说有个很牛逼的大佬曾经去谷歌应聘，结果倒在了这道算法题上，所以看着简单，但还是需要对数据结构这些基础知识拥有足够的重视。</p><p>这个题目看起来是让翻转二叉树，实质上是对二叉树进行遍历，只要能够遍历到结点，就能够实现对该结点的左右子树进行交换，然后要么递归从下往上做要么从上往下依次迭代实现。本文正是借用二叉树的几种遍历算法作为模板进行翻转的。</p><p><strong>解法一：递归翻转</strong></p><pre><code> // 使用递归的方式对二叉树进行翻转public TreeNode invertTree(TreeNode root) {    if (root == null)        return null;    TreeNode lchild = root.left;    TreeNode rchild = root.right;    root.left = invertTree(rchild);    root.right = invertTree(lchild);    return root;}</code></pre><p><strong>解法二：使用层次遍历进行翻转，借用了队列</strong></p><pre><code>// 使用队列对二叉树进行层次遍历的方式进行翻转二叉树public TreeNode invertTree2(TreeNode root) {    if (root == null)        return null;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    queue.add(root);    while(!queue.isEmpty()){        TreeNode cur = queue.poll();        if ((cur.left==null)&amp;&amp;(cur.right==null))            continue;        TreeNode temp = cur.left;        cur.left = cur.right;        cur.right = temp;        if (cur.left!=null)            queue.add(cur.left);        if (cur.right!=null)            queue.add(cur.right);    }    return root;}</code></pre><p><strong>解法三：使用后序遍历进行翻转，借用了栈</strong></p><pre><code> // 使用栈对二叉树进行后序遍历来翻转二叉树public TreeNode invertTree3(TreeNode root) {    if (root == null)        return null;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                TreeNode temp = node.left;                node.left = node.right;                node.right = temp;                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }    return root;}</code></pre><p>  其他的二叉树遍历方法也可以实现对二叉树的翻转，只用对二叉树便利模板程序中访问结点处的程序进行改动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻转二叉树&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       4
     /   \
  2     7
 / \   / \
1   3 6   9&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode算法模板二叉树的遍历</title>
    <link href="http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yxym.run/2020/02/29/LeetCode%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-03-10T14:00:22.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><p>二叉树是n个结点的有限集合，其中n&gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。<br>2、二叉树中不存在度大于2的结点。<br>3、即使只有一棵子树，也要区分它是左子树还是右子树。</p><a id="more"></a><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>关于二叉树的遍历方式有很多种，主要有前、中、后、层次遍历等四种方式，在实现时也有递归的方式和非递归的方式。有很多关于二叉树的算法题目都是基于二叉树的遍历进行展开的，因此我想把二叉树的所有遍历方式进行一次全面的总结。</p><h4 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4><p>1、前序遍历，preVisit(root)</p><p>主要过程为以下三步：</p><ul><li>visit(toot)</li><li>preVisit(root.left)</li><li>preVisit(root.right)</li></ul><p>2、中序遍历，midVisit(root)</p><p>主要过程为以下三步：</p><ul><li>midVisit(root.left)</li><li>visit(toot)</li><li>midVisit(root.right)</li></ul><p>3、后序遍历，postVisit(root)</p><p>主要过程为以下三步：</p><ul><li>postVisit(root.left)</li><li>postVisit(root.right)</li><li>visit(toot)</li></ul><p>具体代码如下：</p><pre><code>public void preVisit(TreeNode root){   if (root==null)       return;   System.out.println(root.val);   preVisit(root.left);   preVisit(root.right);}public void midVisit(TreeNode root){   if (root==null)       return;   midVisit(root.left);   System.out.println(root.val);   midVisit(root.right);}public void postVisit(TreeNode root){   if (root==null)       return;   postVisit(root.left);   postVisit(root.right);   System.out.println(root.val);}</code></pre><h4 id="非递归，借助于栈和队列"><a href="#非递归，借助于栈和队列" class="headerlink" title="非递归，借助于栈和队列"></a>非递归，借助于栈和队列</h4><p>1、前序、中序非递归遍历<br>二者过程类似，只是访问结点的顺序有所差别，具体的代码如下：</p><pre><code>public void preVisitWithStack(TreeNode root){    if (root==null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()) {        while (node!=null){            System.out.println(node.val);            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            node = node.right;        }    }}public void midVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    while (node != null || !stack.isEmpty()){        while (node!=null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.pop();            System.out.println(node.val);            node = node.right;        }    }}</code></pre><p>都是使用两层的while循环，外层循环用于保证栈不是空的或者结点存在，然后内存循环用于一直迭代遍历结点的左子树，直到没有做子树为止，然后方向转向右子树。差别只在于访问元素位置的因为前序和中序的原因而不同。</p><p>2、后序遍历<br>后序遍历也是借助于栈，但是有一个需要注意的是还需要借助一个lastvisit指针，由于后序遍历是先左子树后右子树最后父亲结点，而程序在遍历二叉树的过程中在其左子树已经被访问过以后，什么情况下，才能访问父亲结点？一个就是该父亲结点没有右子树，所以可以直接访问父亲结点，另外一个就是该父亲结点的右子树已经被访问过了，接下来该父亲结点访问了。所以为了记录父亲结点的右子树是否被访问过，就定义了这个指针，这是很关键的一步。</p><pre><code> public void postVisitWithStack(TreeNode root){    if (root == null)        return;    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();    TreeNode node = root;    TreeNode lastVisit = null;    // 此处设置lastVisit指针是为了确认在某个父亲结点拥有右结点的情况下，这个右结点    // 是否已经被访问过了，如果访问了当前结点就要出栈被访问，因为后序遍历的顺序就是左右中    while (node != null || !stack.isEmpty()){        while (node != null){            stack.push(node);            node = node.left;        }        if (!stack.isEmpty()){            node = stack.peek();            if (node.right == null || node.right == lastVisit){                stack.pop();                System.out.println(node.val);                lastVisit = node;                node = null;            }else {                node = node.right;            }        }    }}</code></pre><p>   3、层次遍历<br>   根据层次遍历一层一层访问的特点，可以借助队列结构来完成层次遍历。具体代码实现如下：</p><pre><code>public void levelVisit(TreeNode root){    if (root == null)        return;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.add(root);    while(!queue.isEmpty()){        root = queue.poll();        System.out.println(root.val);        if (root.left != null)            queue.add(root.left);        if (root.right != null)            queue.add(root.right);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的概念&quot;&gt;&lt;a href=&quot;#二叉树的概念&quot; class=&quot;headerlink&quot; title=&quot;二叉树的概念&quot;&gt;&lt;/a&gt;二叉树的概念&lt;/h3&gt;&lt;p&gt;二叉树是n个结点的有限集合，其中n&amp;gt;=0,也就是说该集合要么为空集，要么由一个根节点和两个互不相交的左右子树组成，这两棵左右子树称为是根结点的左子树和右子树。&lt;/p&gt;
&lt;h3 id=&quot;性质：&quot;&gt;&lt;a href=&quot;#性质：&quot; class=&quot;headerlink&quot; title=&quot;性质：&quot;&gt;&lt;/a&gt;性质：&lt;/h3&gt;&lt;p&gt;1、二叉树的左右子树是有顺序的，次序是不能随意颠倒的。&lt;br&gt;2、二叉树中不存在度大于2的结点。&lt;br&gt;3、即使只有一棵子树，也要区分它是左子树还是右子树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第219题</title>
    <link href="http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC219%E9%A2%98/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2020-03-09T14:47:33.131Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p><strong>示例 1:</strong></p><p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p><a id="more"></a><p><strong>示例 2:</strong></p><p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p><p><strong>分析：</strong><br>从这个题目看来，并没有要求有空间复杂度的限制，因此我们可以借助于哈希表来完成以上的操作。</p><p><strong>做法1：</strong><br>其中我的做法是借助于HashMap，以元素值作为哈希表的key值，元素的索引值作为哈希表的value值，利用for循环遍历数组，如果当前key在hashmap中没有值则存入hashmap，如果当前key在hashmap中有值则取出其value，这个value就是数组元素的索引值，然后对当前for循环的游标变量与取出来的value值进行判断，具体的代码实现如下所示：</p><pre><code> public boolean containsNearbyDuplicate(int[] nums, int k) {    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    int flag = 0;    for(int i = 0;i &lt; nums.length;i++){        if (map.get(nums[i])==null){            map.put(nums[i],i);        }else {            int j = map.get(nums[i]);            if (( j!=i)&amp;&amp;(Math.abs(i-j) &lt;= k)){                flag = 1;            }else {                map.put(nums[i],i);            }        }    }    if (flag==1)        return true;    return false;}</code></pre><p>   但是我的这个做法，无论从程序运行时间还是内存消耗，都不是很好，因此我查看了一些性能比较好的程序，在此学习记录。</p><p>**   做法2：**<br>  思路：用散列表来维护这个kk大小的滑动窗口。<br>  这个做法借助了hashset，通过设立这个集合，确保这个集合中的元素数量不大于k，一旦大于k就要删去最先存入集合的元素，其中如果在for循环结束前，要存入的元素在集合中存在了，则说明题目中所要求的那两个相等的元素找到了，如果在for循环结束以后还是没有返回true，则说明没有符合条件的元素则返回false。这个程序的作者设计的很巧妙，相比于我的程序，运行速度要快的多。<br>  具体的代码如下：</p><pre><code>public boolean containsNearbyDuplicate2(int[] nums, int k) {    if(k==35000) return false;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int i = 0; i &lt; nums.length; ++i) {        if (set.contains(nums[i])) return true;        set.add(nums[i]);        if (set.size() &gt; k) {            set.remove(nums[i - k]);        }    }    return false;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: nums = [1,0,1,1], k = 1&lt;br&gt;输出: true&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记之第190题</title>
    <link href="http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/"/>
    <id>http://yxym.run/2020/02/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AC%AC190%E9%A2%98/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-03-07T14:27:08.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例：</p><pre><code>输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</code></pre><a id="more"></a><p><strong>注意：</strong><br>我用的是Java语言，但是在Java语言中，没有无符号整型，在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响我们的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p><p>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p><strong>解题思路：</strong></p><p>将一个32位的整数的二进制形式进行翻转，对于二进制形式的数，可以考虑采用位运算。并且需要注意的是有一点是对于任意的整数n，对它与1进行进行“与”运算，最终得到的结果都取决于该数字最后一位，如果是1，则说明n的二进制形式中，最后一位是1；如果是0，则说明n的二进制形式中，最后一位是0。通过这种方式，可以逐个的提取n的二进制位中的每一位数字。基于以上思路，有以下两种翻转方式：</p><ol><li>从左向右移位置，提取最后一位，从右向左移位，或运算</li></ol><p>取一个游标变量i，其取值从31到0，表示先提取n的二进制形式的最后一位，然后将倒数第二位右移到最后一位，提取；继续将倒数第三位右移到最后一位，，以此类推。代码如下：</p><pre><code>（n &gt;&gt; (31-i)）&amp; 1</code></pre><p>取完最后一位的值以后，将其进行左移，左移的位数整数前边右移时的游标变量i的值，根据对称的性质可知，翻转正是将第31位移到第0位，第30位移到第1位；代码如下：</p><pre><code>（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>再声明一个结果变量result，初始值为0，它将与每次左移后的结果进行“或”运算，经过31次或运算之后，它就是最终的翻转的结果值。</p><pre><code>result |（(n &gt;&gt; (31-i)）&amp; 1）&lt;&lt; i</code></pre><p>完整的代码实现如下：</p><pre><code>public int reverseBits(int n) {       int ret = 0;    for (int i =31;i&gt;=0;i--){       ret = ret | (((n&gt;&gt;(31-i))&amp;1) &lt;&lt; i);   }   return ret; }</code></pre><p>  ii. 第二种方式，是我在题解中看到的一个内存空间消耗较少的程序，因为上一个方法虽然运行时间特别快，超过了100%的人，但是内存消耗却只超过了5%的人的程序。在这个方式中，也是声明了一个结果变量ret，但是它并没有先右移，然后提取，再左移，最后或运算；而是也对res变量进行移位操作，即先将res左移，提取完原数的最后一位之后与res或运算，然后直接将就地对n右移，完整的代码如下：</p><pre><code>public int reverseBits2(int n){    int res = 0;    int count = 0;    while (count &lt; 32) {        res &lt;&lt;= 1;        res |= (n &amp; 1);        n &gt;&gt;= 1;        count ++;    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="刷题笔记" scheme="http://yxym.run/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>GO语言学习之函数</title>
    <link href="http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%80/</id>
    <published>2020-02-26T14:41:00.000Z</published>
    <updated>2020-02-26T14:43:50.613Z</updated>
    
    <content type="html"><![CDATA[<p>在go语言中,函数存在以下几个与其他编程语言显著不同的地方:<br>1、函数可以有多个返回值<br>2、所有的参数传递都是值传递的方式<br>3、函数可以作为变量的值<br>4、函数可以作为参数和返回值</p><p>本文主要针对第四点来进行笔记记录</p><a id="more"></a><h3 id="函数可以作为参数和返回值"><a href="#函数可以作为参数和返回值" class="headerlink" title="函数可以作为参数和返回值"></a>函数可以作为参数和返回值</h3><p>首先定义一个函数timeSpent，它的作用类似于面向对象编程中的装饰者模式，对一个函数“装饰”上记录运行时间的功能，以此来衡量一个函数的运行时间，其中被衡量的函数是作为参数传入到timeSpent中去的，代码如下：</p><pre><code>func timeSpent(inner func(op int) int) func (opt int) int{return func(n int) int {    start := time.Now()    ret := inner(n)    fmt.Println(&quot;time spent&quot;,time.Since(start).Seconds())    return ret}}</code></pre><p>其中，传入的参数是一个函数类型，该参数函数的返回值是一个整型，timeSpent的返回值类型也为一个函数类型。</p><p>然后定义一个用来测试的函数：</p><pre><code>func slowFun(op int) int{    time.Sleep(time.Second*1)    return  op}</code></pre><p>该函数并没有多余的功能，只是将传入的参数再次原值返回，期间函数会休眠一段时间。</p><p>调用执行：</p><pre><code>func TestFn(t *testing.T)  {tsSF := timeSpent(slowFun)t.Log(tsSF(10))}</code></pre><p>程序的执行过程如下：<br>1、首先将slowFun函数作为参数传入到timeSpent中去，然后将其装饰为一个具有记录运行时间的函数后，返回一个被装饰的函数，return后方的函数内部逻辑并不执行，只是将原有的函数进行装饰；<br>2、tsSF被赋予一个函数，该函数的具体业务逻辑等同于timeSpent函数中return语句后方的函数；<br>3、调用执行tsSF，传入参数10，执行逻辑见timeSpent中return语句后方的部分，打印输出10。</p><p>以上就是go语言中函数作为参数和返回值的实例，此种编程模式也成为函数式编程，可以在《计算机程序的构造与解释》这本书中了解更多更深入的关于函数式编程的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在go语言中,函数存在以下几个与其他编程语言显著不同的地方:&lt;br&gt;1、函数可以有多个返回值&lt;br&gt;2、所有的参数传递都是值传递的方式&lt;br&gt;3、函数可以作为变量的值&lt;br&gt;4、函数可以作为参数和返回值&lt;/p&gt;
&lt;p&gt;本文主要针对第四点来进行笔记记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go语言学习笔记" scheme="http://yxym.run/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>大学回忆一</title>
    <link href="http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/"/>
    <id>http://yxym.run/2020/02/26/%E5%A4%A7%E5%AD%A6%E5%9B%9E%E5%BF%86%E4%B8%80/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2020-02-26T15:18:24.181Z</updated>
    
    <content type="html"><![CDATA[<p>时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。<a id="more"></a>回望本科四年，心中却没有泛起丝毫波澜，或许是因为大学生活过的平凡无奇，或许是因为年过20早已没有了十几岁的热情与心气。</p><p>本科四年，是我特别想要证明自己的四年，或许是因为对高考结果的不满，或许是因为对自己的不甘心，总之在踏入校园的那一刻起，我发誓我一定要做一个追逐优秀的人，我没有对任何说，因为我也不认识任何人，哈哈哈。可就是这股力量一直在驱动着我前进，我努力地学习每一门课程，以使自己对所学的课程都能有一个深刻的认识与理解而不是简单地只为拿一个不错的期末分数，诚然，我这么学，每一门分数也都是很理想的，当然，英语除外，其实我当年英语也他挺好的，只是后来碰到了一位经常把我讲睡着的英语老师，然后就对英语彻底丧失了兴趣，以至于英语成绩一直不愠不火，哈哈哈。</p><p>我大学是软件工程，其实我在上大学之前对计算机的认识只有能打游戏和能做PPT这两种认识，更别说那些什么CPU、GPU、内存等什么专业术语，一开学的时候我挺自卑的，因为别人能一起侃侃而谈，我却对此一窍不通，这种感觉严重的刺痛了我，妈的，老子不能服输，因此我一边学习理论知识，一边了解计算机相关的知识，不管是硬件还是软件，只要是和Computer相关，我都会刻意去了解，慢慢滴也对这些知识熟悉了起来。另一个自卑的就是自己的编程能力了，有的同学大一的时候就能参加竞赛拿奖而我还只是一个臭弟弟，没办法，我这个人就是比较的自找没趣，喜欢和比我强的人比，也许是我争强好胜的原因，其实这一点挺不好的，因为容易把自己的心态搞砸了，心态一旦失衡，做什么事都容易翻车。扯远了，继续刚才的话题，为让自己也能编程能力有个大的提高，自己也在寒暑假学习编程语言，练习编程。虽然不能说自己能力提高了很多，但是起码上手的速度快了很多。现在回忆那些生活，突然有些小怀念了，哈哈哈，总之那段生活挺单调的，因为自己没交多少朋友，甚至能连学校有多少好吃的都不知道哈哈哈，因为每天标准的吃米饭套餐，哎，人生苦短，要及时行乐啊，不能苦了自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间如白驹过隙，稍纵即逝，脑海里我还是一个特别热爱写作的青少年，可现在想写一篇大学生活的回忆却突然久久无法下笔了，或许是太久没有安静地的去思考了，或许是在手机的世界里习惯了浮躁与喧闹失去了自己的思考与心声。
    
    </summary>
    
    
      <category term="活有所思" scheme="http://yxym.run/categories/%E6%B4%BB%E6%9C%89%E6%89%80%E6%80%9D/"/>
    
    
  </entry>
  
</feed>
